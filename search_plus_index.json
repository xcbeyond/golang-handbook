{"./":{"url":"./","title":"序言","keywords":"","body":"序言 “Go will be the server language of the future.” — Tobias Lütke, Shopify 在过去几年，崛起了一门新的语言：Go 或者 GoLang。没有什么比一门新的编程语言更令开发者兴奋了，不是么? 图 1.1.1：golang 目前一些开源社区，纷纷采用 Go 语言开发了许多平台、框架等，如：Docker、Kubernetes等，甚至逐步从其它语言（如：C、Java 等）转换到了 Go，相信这一点你已经体会到了。当您在看一些开源代码时，全是 Go 语言编写的，你该咋办呢？ 此外，伴随着近两年来云原生技术的发展迅猛，Go 语言作为新生代的编译型编程语言，凭借语法简单、高并发性能良好和编译速度快等特点，成为了云原生技术落地实践的绝妙利器。云原生的到来，这也将迫使您不得不多学习一门新语言了。 因此，从今天开始从零开始学 Go 语言，一方面是督促自己不断前行且学习新的知识，另一方面是分享给读者，希望与大家一起进步。该电子书将从零基础开始，以通俗易懂的方式一起学习、分享 Go 语言的学习历程，不断归档总结，且看且珍惜吧，加油！ 适合人群： 编程爱好者 Go语言初学者 学习目标： 帮助 Go 语言小白快速学习 Go 语言基础知识，从不了解到了解，到会写 Go 语言程序，到入门，直到精通，作为Go语言系列全教程。 废话不多说，奥力给！ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 17:16:25 "},"introduction/golang-introduce.html":{"url":"introduction/golang-introduce.html","title":"Go语言介绍","keywords":"","body":"Go语言介绍 1、Go语言介绍 Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. “Go 是一种开源的程序设计语言，它意在使得人们能够方便地构建简单、可靠、高效的软件。”（来自Go 官网golang.org的定义） Go 语言，又称为 Golang，在 2007 年 9 月形成构思，并于 2009 年 11 月发布，其发明人是 Google 的 Robert Griesemer, Rob Pike 和 Ken Thompson。该语言其及配套工具集使得编译和执行既富有表达力又高效，而且使得程序员能够轻松写出可靠、健壮的程序。 Go 的吉祥物是金花鼠（gordon），并将其作为 logo，如下图所示： Go 是从 2007 年末由 Robert Griesemer, Rob Pike, Ken Thompson 主持开发，后来还加入了 Ian Lance Taylor, Russ Cox 等人，并最终于 2009 年 11 月开源，在 2012 年早些时候发布了 Go 1 稳定版本。现在 Go 的开发已经是完全开放的，并且拥有一个活跃的社区。 1.1 Go 的起源 编程语言的演化跟生物物种的演化类似，成功的语言会繁衍后代，这些后代语言会从它们的祖先那里汲取各种优点。有时候，语言间的“混血”会产生异常强大的力量；在一些罕见情况下，某个重大的语言特性也可能凭空出现而无先例。通过观察语言间的影响，我们可以学到不少知识，比如语言为什么会变成这个样子，以及它适合用于哪些环境等等。 下图展示了有哪些早期的编程语言对 Go 语言的设计产生了重要影响。 图 2.1.1：Go语言的演进过程 Go 有时会称为“类 C 语言”，或者是“21 世纪的 C 语言”。从 C 中，Go 继承了相似的表达式语法、控制流结构、基本数据类型、按值调用的形参传递和指针，但比这些更重要的是，继承了C所强调的要点：程序要编译成高效的机器码，并自然地与所处的操作系统提供的抽象机制相配合。 但是在 Go 语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有 Oberon 语言的面向对象特性所提供的方法的声明语法等。 Go 语言的另一支祖先，带来了 Go 语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献 顺序通信进程 （ communicating sequential processes ，缩写为CSP。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。 接下来，Rob Pike 和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的Newsqueak语言，提供了类似 C 语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak 是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在 Newsqueak 语言中管道是动态创建的，属于第一类值, 可以保存到变量中。 在 Plan9 操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在 Alef 之后还有一个叫Limbo的编程语言，Go 语言从其中借鉴了很多特性。 具体请参考 Pike 的讲稿：http://talks.golang.org/2012/concurrency.slide#9 ） Go 语言的其他的一些特性零散地来自于其他一些编程语言；比如 iota 语法是从APL)语言借鉴，词法作用域与嵌套函数来自于Scheme)语言（和其他很多语言）。当然，我们也可以从 Go 中发现很多创新的设计。比如 Go 语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有 Go 语言新发明的 defer 语句。 1.2 Go 的特点 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 1.3 Go 的用途 其它语言能够实现的系统，Go 语言都能实现。 目前，Go 主要应用在下面这些系统： 服务器编程，以前你如果使用 C 或者 C++ 做的那些事情，用 Go 来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统、数据库代理器等，比如 Etcd。 网络编程，这一块目前应用最广，包括 Web 应用、API 应用、下载应用，而且 Go 内置的 net/http 包基本上把我们平常用到的网络功能都实现了。 数据库，前一段时间 Google 开发的 Groupcache，Couchbase 的部分组件，Tidb，Cockroachdb，Influxdb 等。 云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的Apcera云平台。 云原生技术，比如docker、Kubernetes等。 1.4 Go 的美貌 说了这么多，Go 程序到底长啥样？我们先睹为快，一看美貌！ 来来来，以 hello.go 为例看看它长啥样。（Go 语言源文件的扩展是 .go） package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 2、为什么我们要学习Go？ 就我而言，目前主要从事微服务方面的产品研发，之前一直使用Java语言作为核心编程语言，但随着市场的变化，Java有时变得力不从心（一些轻量级的功能模块实现时，Java却显得有些笨重）。此外，为迎接云原生技术的到来，学习Go成为了必然。 对于你而言，为什么要学习Go呢？下面我参考知乎和网上大神的答案，谈谈Go语言的优势。 Go 语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 C/C++ 的问题 开发效率低，对开发者要求高；libc 只向后兼容，运维难度偏大。 Lua/Python 的问题 动态语言，缺少编译过程，低级错误频出；缺少有效的性能分析及调试工具。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/install.html":{"url":"introduction/install.html","title":"开发环境搭建","keywords":"","body":"开发环境搭建 1、Go语言环境安装 1.1 开发包获取 Go 语言支持以下系统： Windows Linux Mac：也称为 Darwin FreeBSD 开发包下载地址为：https://golang.org/dl 如果打不开可以使用这个地址：https://golang.google.cn/dl 根据你的系统，选择下载对应的开发包。 图 2.2.1：Go-installer-package 以 Windows 系统为例，下载 Windows 的安装包 go1.16.windows-amd64.msi，下载地址：https://golang.google.cn/doc/install?download=go1.16.windows-amd64.msi 1.2 开发包安装 （1）安装开发包。 双击下载的安装包 go1.16.windows-amd64.msi，一步步安装即可。 默认情况下，会安装在 C:\\Program Files\\Go 目录下。（不同版本会存在差异，以实际为准！） （2）配置 Go 环境变量。 默认情况下，安装完开发包会自动配置 Go 环境变量，如若未配置或配置不符合自己需求（GOPATH 可按照自己的实际情况配置），则安装下面的配置方法配置或进行调整。 根据 Windows 系统在查找可执行程序的原理，可以将 Go 所在路径定义到环境变量中，让系统帮我们去找到运行执行的程序，这样任何目录都可以执行 go 指令。配置的环境变量如下所示： 环境变量 说明 Path 添加 Go 开发包的 /bin 目录，如：C:\\Program Files\\Go\\bin GOPATH 工作目录，设置 Go 项目的工作路径，可根据自我喜好设置。 右键“我的电脑”-> 属性 -> 高级系统设置 -> 高级 -> 系统变量： 图 2.2.2：环境变量设置 添加的环境变量如下： Path：C:\\Program Files\\Go\\bin 图 2.2.3：配置环境变量Path GOPATH：E:\\github\\golangLearning，自定义目录，作为后续 Go 工程目录。 （3）环境检验。 打开 cmd 命令行，执行 go version，检查是否安装成功并生效。 图 2.2.4：go-version执行结果 2、IDE 安装 2.1 IDE 工具 常用的 Go 开发 IDE 如下所示： Visual Studio Code（简称 VSCode） 微软的产品，一个运行于 Mac OS、Windows 和 Linux 之上的工具，默认提供 Go 语言的语法高亮。安装 Go 语言插件，还可以支持智能提示，编译运行等功能。 Sublime Text 可以免费试用，默认也支持Go代码语法高亮，只是保存次数达到一定数量后需要购买。 Vim 它是从 vi（Linux）发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能非常丰富。 Emacs 它不仅仅是一个编辑器，因为功能强大，可称为集成开发环境。 Eclipse IDE 工具 开源免费，并提供 GoEclipse 插件。 LiteIDE LiteIDE 是一款专门为 Go 语言开发的跨平台轻量级集成开发环境（IDE），是国人开发的。 JetBrains公司的产品 GoLand、PhpStrom、WebStrom 和 PyCharm 等 IDE 工具，都需要安装 Go 插件。 Go 语言的 IDE 工具很多，可根据自我喜好自行选择，不做强制要求。 （建议大家先选择使用 VSCode，这样能让你更好地理解 Go 语言、基本语法和关键字等。等熟悉 Go 的语法后，再切换到自己顺手的 IDE 即可。） 2.2 安装 VSCode 下载地址：https://code.visualstudio.com/ 图 2.2.5：VSCode下载页面 下载页面可以选择不同版本供大家下载。 我选择了 Windows x64 版本下载，并直接安装即可。 2.3 VSCode 配置 Go 语言插件 （1）首先安装 Go 语言插件： 图 2.2.6：VSCode安装Go语言插件 （2）配置 Go 开发环境包 VSCode 中，快捷键 ctrl+shift+p 打开，输入 go:install： 图 2.2.7：VSCode插件安装go install 并选中 Go:Install/Update Tools 回车，并全部勾选，确认： 图 2.2.8：VSCode插件安装go install Tools environment: GOPATH=E:\\github\\golangLearning Installing 9 tools at E:\\github\\golangLearning\\bin in module mode. gopkgs go-outline gotests gomodifytags impl goplay dlv golint gopls 省略…… Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (E:\\github\\golangLearning\\bin\\gopkgs.exe) SUCCEEDED Installing github.com/ramya-rao-a/go-outline (E:\\github\\golangLearning\\bin\\go-outline.exe) SUCCEEDED 省略…… All tools successfully installed. You are ready to Go :). 2.4 Go 语言程序快速运行 （1）VSCode 打开刚刚创建的 GOPATH 工程目录。 （2）创建一个新的文件 test.go，编写 Hello, World! Go 程序，代码如下： package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 保存文件后，VSCode 会自动检测到可能需要安装的扩展包或插件，此时我们会看到右下角有弹框提示，如下所示。此时我们暂时忽略，无需安装。 图 2.2.9：VSCode安装Go扩展包 （3）快速运行。 VSCode 中 “Terminal” -> New Terminal，执行 go run test.go 命令直接运行 test.go 程序，结果如下： （实际环境是需要先编译(go build)后运行。go run 命令的执行时间较长，是因为其中包含编译过程。） 图 2.2.10：go run示例 到此，Go 语言开发环境搭建完毕！ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/first-golang-program.html":{"url":"introduction/first-golang-program.html","title":"编写第一个Go程序","keywords":"","body":"编写第一个 Go 程序 在开始 Go 语言的基本语法、函数和高级特性等之前，让我们先编写第一个 Go 程序 “Hello World” 开始，来了解 Go 语言最简单程序的结构吧，看看 Go 程序应该包括哪些部分，每部分都位于什么位置，Go 语言究竟是如何执行的。 我们依然从永恒的 “hello,world” 程序开始，hello.go 源代码如下： package main import \"fmt\" func main() { // \"Hello World!\" Go语言程序 fmt.Println(\"Hello World!\") } 让我们来看下以上程序的各个部分： 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。 package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import fmt 告诉 Go 编译器这个程序需要使用 fmt 包中的函数或其他元素，fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数（入口函数）。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数），等同于 Java 中的 public static void main(String[] agrs)。 下一行 // 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。（与其他语言相同） 下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n 换行。使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台，后续会单独讲解 fmt 包相关的内容。 1、Go语言结构 从上面的 hello world 程序可以看出，一个完整 Go 语言的程序结构由以下几部分组成： 包声明 引入包 函数 变量 语句 & 表达式 注释 2、执行流程 Go程序源文件是以 .go 作为后缀的文件，有两种执行流程： 1、将源文件先编译成可执行的二进制文件，再运行。 编译源代码：go build 命令，生成可执行文件。 运行可执行文件：直接运行可执行程序文件。 常用于在 Go 编译环境上编译生成可执行的二进制文件，并将可执行的二进制文件部署在任何没有 Go 编译环境的机器上。 图 2.3.1：go build运行流程 2、直接对源文件执行 go run 命令。 常用于开发环境测试使用。（go run 必须依赖 go 开发编译环境） 图 2.3.2：go run运行流程 3、开发注意事项 Go 源文件以 “go” 为扩展名，如：hello.go。 Go 应用程序的执行入口是 main() 函数。 Go 语言严格区分大小写。 Go 方法是由一条条语句构成，每个语句后不需要分号 ; 结束（实际上 Go 语言会自动在每行后加分号），这也体现了 Go 语言的简洁性。 Go 编译器是一行行编译的，因此我们一行就写一条语句，不能把多条语句写在同一行，否则报错。 Go 语言定义变量或者 import 的包如果没有使用到，则代码不能编译通过。 大括号都是成对出现的。 大括号 { 不能单独放在一行。如： package main import \"fmt\" func main() { // 错误，{不能单独成行 fmt.Println(\"Hello World!\") } Go 语言有内置 gofmt 工具，能够自动整理代码多余的空白、变量名称对齐、并将对齐空格转换成 Tab。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/goproxy.html":{"url":"introduction/goproxy.html","title":"Go代理goproxy","keywords":"","body":"Go 代理 goproxy 在逐步编写 Go 程序时，会涉及使用到第三方提供的Go依赖包，如：github.com/spf13/cobra，在国内使用 go get 命令安装时经常会出现 timeout 等问题，实在让人头疼。大家都知道，在国内网络环境下，想要解决这种问题，只有掌握科学上网才能彻底解决。但是xx上网却是需要花费额外成本的，那该怎么办呢？ 本文将会介绍一种Go代理 goproxy 的方式来解决上述问题，让你既不花钱，又能快速下载安装。 1、goproxy.cn 介绍 Go 的 1.11 版本以后可以设置环境变量 GOPROXY，来设置代理，以加速下载。目前国内使用最多的是 goproxy.cn，号称中国最可靠的Go模块代理。 图 2.4.1：goproxy.cn 它有以下特点： 极速下载： 我们正在使用七牛云 CDN 在全球范围内加速我们的服务，并且我们没有设置任何带宽限制。凭借着数以千计的 CDN 节点和 40Gbps+ 的单节点带宽，你将被赋予一个以极快的速度下载模块版本的能力。 没有限制： 我们不但没有设置带宽限制。更进一步地，我们还没有设置任何速率限制。这意味着你可以在任何场景下使用我们的服务，例如 CI/CD。你甚至可以像 goproxy.baidu.com 一样将我们的服务用作上游代理。 功能齐全： 我们一直在使用最新的 Go 版本，甚至是不稳定版本。因为我们提供了最前沿的功能支持。特别地，我们支持代理默认的校验和数据库 sum.golang.org。你不需要做任何额外的事情，它就可以工作。 数据可视： 为了使大家可以更好地了解我们的服务中所有模块的活跃度，我们推出了 Go 模块代理世界中的首个统计数据 API。通过得体的 RESTful API 设计，你将能够轻松地查询我们服务中所有模块版本的统计数据。 2、goproxy.cn 配置 推荐在 Go 1.13 以上版本使用。 打开你的终端执行下面命令： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct macOS 或 Linux： export GO111MODULE=on export GOPROXY=https://goproxy.cn 或者 echo \"export GO111MODULE=on\" >> ~/.profile echo \"export GOPROXY=https://goproxy.cn\" >> ~/.profile source ~/.profile Windows： 打开 cmd 命令行，执行： C:\\> $env:GO111MODULE = \"on\" C:\\> $env:GOPROXY = \"https://goproxy.cn\" 3、小结 有上述 goproxy 代理的设置，go get 命令下载将会变得很快，轻松解决了 timeout 问题。此外，也可以通过国外 goproxy.io 代理完成加速，配置方法和 goproxy.cn 完全一样。 参考文章： https://goproxy.cn https://www.goproxy.io/zh/ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"basics/basic-syntax.html":{"url":"basics/basic-syntax.html","title":"基础语法","keywords":"","body":"基础语法 与其他编程语言一样，Go 语言项目（大程序）都是从基本组件和基本语法编写而成。上一章节我们已经了解了 Go 语言的样子，本章节我们将学习 Go 语言的基础语法，也将是接下来所有 Go 程序中不可或缺的部分。 1、命名规则 Go 中类型、变量、常量、语句标签、包和函数的命名都遵循一个简单的规则：命名的开头是一个字母或下划线而不能是数字，后面可以跟任意数量的字符、数字和下划线，并区分大小写。 如, xcbeyond 和 xcBeyond 是不同的标识符。 以下是有效的标识符： mahesh kumar abc move_name a_123 myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab：以数字开头 case：Go 语言的关键字 a+b：运算符是不允许的 2、关键字 Go 语言和其他语言一样，也有一些关键词供程序使用。Go 中有 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 3、注释 注释，是为了增强代码的可读性，但不参与程序的一切功能，不会被编译。每个程序都应该在适当的位置添加注释，用于功能、实现、标注等说明，如果你不想不其他人唾弃，请一定养成编写注释的习惯，注释和代码同样重要。 Go 语言的注释主要分为两类： 单行注释：你可以在任何地方使用以 // 开头的单行注释，是最常见的注释形式。 多行注释：也叫块注释，以 /* 开头，并以 */ 结尾。 如下所示： package main import \"fmt\" func main() { // \"Hello World!\" Go语言程序 fmt.Println(\"Hello World!\") // 这是一个单行注释 /* 这是一个多行注释 by xcbeyond */ } 4、行分隔符 在 Go 程序中，一行代表一个语句结束。每个语句不需要像 Java 等其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： fmt.Println(\"Hello, World!\") fmt.Println(\"Hello, xcbeyond!\") 5、字符串输出 Go 语言的字符串输出可以通过函数 fmt.Println 或 fmt.Print 实现，fmt.Println 会输出后换行，类似于 Java 语言中的 System.out.println 和 System.out.print。 如下所示： package main import \"fmt\" func main() { // 输出后换行 fmt.Println(\"xcbeyond，帅么？\") // 输出后不换行 fmt.Print(\"帅!\") fmt.Print(\"太帅了!\") } 输出结果： xcbeyond，帅么？ 帅!太帅了! 此外，字符串输出还可以进行格式化输出，后续章节会进行介绍。 6、字符串拼接 Go 语言的字符串拼接最常用的方法是通过 + 实现： package main import \"fmt\" func main() { fmt.Println(\"xc\" + \"beyond\") } 输出结果： xcbeyond + 实现拼接，会产生一个新的字符串对效率有所影响。除此之外，还可以借助函数 fmt.Sprintf、strings.Join、buffer.WriteString 等实现，后续字符串章节会详细介绍。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/variables.html":{"url":"basics/variables.html","title":"变量","keywords":"","body":"变量 变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。 Go 语言是静态类型语言，因此变量（variable）是有明确类型的，编译器也会检查变量类型的正确性。 变量可以通过变量名访问。 Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 1、变量的声明 声明变量的一般形式是使用 var 关键字： var name type 其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。 还可以一次声明多个类型相同的变量： var name1,name2,name3 type 需要注意的是，Go 语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b; 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型： var a, b *int 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。 示例如下： package main import \"fmt\" func main() { var a,b int fmt.Println(a,b) } 输出结果如下： 0 0 变量的声明有多种形式，整理归纳如下。 1.1 标准声明格式 Go 语言的变量声明的标准格式如下： var 变量名 变量类型 或 var 变量名1,变量名2 变量类型 变量声明以关键字 var 开头，后置变量类型，行尾无须分号。 如果没有初始化，则变量默认为零值。（零值就是变量没有做初始化时系统默认设置的值。） var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。 示例如下： package main import \"fmt\" func main() { // 声明一个没有初始化的int类型变量，默认为零值0 var a int fmt.Println(a) // 声明一个没有初始化的bool类型变量，默认为零值false var b bool fmt.Println(b) } 输出结果如下： 0 false 1.2 根据值自行判定变量类型 var 变量名 = 变量值 示例如下： package main import \"fmt\" func main() { var c = true fmt.Println(c) } 输出结果如下： true 1.3 短变量声明 在函数中，一种称为短变量声明的可选形式可以用来声明和初始化局部变量。格式如下： 变量名 := 变量值 这里省略了关键字 var，变量名的类型由变量值的类型决定，变量值可以是任何函数或表达式计算的结果值。 因其短小、灵活，故而在局部变量的声明和初始化中主要使用。 短变量声明有以下注意点： 定义变量，同时显式初始化。 不能直接提供数据类型。 只能用在函数内部。 := 表示声明，而 = 表示赋值。 := 左侧如果是已声明的变量，就会产生编译错误。如： var intVal int intVal := 1 // 会产生编译错误 示例如下： package main import \"fmt\" func main() { // 短变量声明 d := \"xcbeyond\" fmt.Println(d) } 输出结果如下： xcbeyond 1.4 批量声明 觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法： var ( a int b string c float64 ) 使用关键字 var 和括号，可以将一组变量定义放在一起。 示例如下： package main import \"fmt\" func main() { // 批量声明 var ( e int f string g float64 ) fmt.Println(e,f,g) } 输出结果如下： 0 0 2、变量的初始化 变量初始化标准格式如下： var 变量名 类型 = 变量值 如： var i int = 100 i 为变量名，类型为 int，i 的初始值为 100。 上面代码中，100 和 int 同为 int 类型，int 可以认为是冗余信息，因此可以进一步简化初始化的写法。 在标准格式的基础上，将 类型 int 省略后，编译器会尝试根据等号右边的变量值推导出变量的类型。如： var i = 100 短变量声明并初始化，如： i := 100 这是 Go 语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。 3、变量的多重赋值 赋值是用来更新变量所指的值，它最简单的形式由赋值符 =，以及符号左边的变量和右边的表达式组成。 x = 1 person.name = \"xcbeyond\" count[x] = count[x] * 5 另一种形式的赋值是多重赋值，它允许几个变量一次性被赋值。 在 Go 语言语法中，变量初始化和变量赋值是两个不同的概念，Go 语言的变量赋值与其他语言一样，但是 Go 语言提供了其他程序员期待已久的多重赋值功能，可以实现变量交换。多重赋值让 Go 语言比其他语言减少了代码量。 以简单的算法交换变量为例，传统写法如下所示： var a int = 10 var b int = 20 var tmp int tmp = a a = b b = t fmt.Println(a, b) 新定义的变量 tmp 是需要内存的，于是有人设计了新的算法来取代中间变量，其中一种写法如下所示： var a int = 10 var b int = 20 a = a ^ b b = b ^ a a = a ^ b fmt.Println(a, b) Go 语言有了多重赋值功能，则简单写法如下所示： var a int = 10 var b int = 20 b, a = a, b fmt.Println(a, b) 从以上例子来看，Go 语言的写法明显简洁了许多，需要注意的是，多重赋值时，左值和右值按照从左到右的顺序赋值。这种方法在错误处理和函数当中会大量使用。 4、匿名变量 在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。 匿名变量的特点是一个下画线 _，_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。 例如，我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。在 Go 中这种情况可以通过结合使用多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅。 假设 GetName() 函数的定义如下，它返回 3 个值，分别为 firstName、lastName 和 nickName，若只想获得 nickName，则可以用如下方式编写： package main import \"fmt\" func main() { // 匿名变量 firstName, _, _ := getName() _, lastName, _ := getName() _, _, nickName := getName() fmt.Println(firstName, lastName, nickName) } func getName() (firstName, lastName, nickName string) { return \"X\", \"C\", \"xcbeyond\" } 输出结果如下： X C xcbeyond 这种用法可以让代码非常清晰，基本上屏蔽掉了可能混淆代码阅读者视线的内容，从而大幅降低沟通的复杂度和代码维护的难度。 匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。 5、变量的作用域 一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。 了解变量的作用域对我们学习Go语言来说是比较重要的，因为Go语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。 根据变量定义位置的不同，可以分为以下三个类型： 局部变量：函数内定义的变量。 全局变量：函数外定义的变量。 形式参数：函数定义中的变量。 下面就来分别介绍一下。 5.1 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。 局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。 main() 函数中使用到了局部变量 a、b、c，示例如下： package main import \"fmt\" func main() { // 声明局部变量a和b并赋值 var a int = 3 var b int = 4 // 声明局部变量c.并计算a和b的和 c := a + b fmt.Printf(\"a = %d, b = %d, c = %d\\n\", a, b, c) } 输出结果如下： a = 3, b = 4, c = 7 5.2 全局变量 在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用 import 关键字引入全局变量所在的源文件之后才能使用这个全局变量。 全局变量声明必须以 var 关键字定义，如果想要在外部包中使用全局变量的首字母必须大写。 定义全局变量 c，示例如下： package main import \"fmt\" // 声明全局变量 var c int func main() { //声明局部变量 var a, b int //初始化参数 a = 3 b = 4 c = a + b fmt.Printf(\"a = %d, b = %d, c = %d\\n\", a, b, c) } 输出结果如下： a = 3, b = 4, c = 7 Go 语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。 5.3 形式参数 在定义函数时，函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。 形式参数会作为函数的局部变量来使用。 函数 sum(a, b int) 定义了形式参数 a、b，示例如下： package main import \"fmt\" func main() { sum := sum(1,3) fmt.Println(sum) } // 两数求和 func sum(a, b int) int{ num := a + b return num } 输出结果如下： 4 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/data-types.html":{"url":"basics/data-types.html","title":"数据类型","keywords":"","body":"数据类型 Go 语言是一种静态类型的编程语言，在 Go 编程语言中，数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。编译器在进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。 Go 语言按类别有以下几种数据类型： 图 3.3.1：Go语言数据类型 下面将针对各种数据类型的使用展开详细的说明。 1、基本数据类型 1.1 布尔型 布尔类型的值只有两种：true 或 false。在if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 等比较操作也会产生布尔型的值。 一元操作符 ! 对应逻辑非操作，因此 !true 的值为 false，更复杂一些的写法是 (!true==false) == true，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示 x==true。 var a = 10 fmt.Println(a == 10) // true fmt.Println(a == 5) // false fmt.Println(a != 10) // false fmt.Println(a != 5) // true Go 语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。 var a = 10 fmt.Println(a == true) // cannot use true (type untyped bool) as type int 布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的： s != \"\" && s[0] == 'x' Go 语言中不允许将整型强制转换为布尔型，代码如下： var n bool fmt.Println(int(n) * 2) // cannot convert n (type bool) to type int 1.2 数值型 Go 语言的数值类型分为以下几种：整数、浮点数、复数。其中每一种都包含了不同大小的数值类型，例如有符号整数包含 int8、int16、int32、int64 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。本小节我们主要介绍一下数值类型。 1.2.1 整型 Go 语言也是基于架构的类型，同时提供了有符号和无符号的整数类型，具体如下： 类型 字节 描述 数据范围 uint8 1 无符号8位整型 0 ~ 255（28-1） uint16 2 无符号16位整型 0 ~ 65535（216-1） uint32 4 无符号32位整型 0 ~ 232-1 uint64 8 无符号64位整型 0 ~ 264-1 int8 1 有符号8位整型 -128（2-7-1） ~ 127（27-1） int16 2 有符号16位整型 -32768（2-15-1） ~ 65535（215-1） int32 4 有符号32位整型 2-31-1 ~ 231-1 int64 8 有符号64位整型 2-63-1 ~ 263-1 int 4或8 有符号32或64位整型 取决于编译器和计算机硬件 uint 4或8 无符号32或64位整型 取决于编译器和计算机硬件 uintptr 4或8 用于存放一个指针 取决于编译器和计算机硬件 有符号：用最高位表示符号（正或负），其余位表示数值大小。 无符号：所有位都用于表示数的大小。 1 字节 = 8 位 大多数情况下，我们只需要 int 一种整型即可，它可以用于循环计数器（for 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 int 类型的处理速度也是最快的。 1.2.2 浮点型 Go 语言提供了两种精度的浮点数：float32 和 float64，这些浮点数类型的取值范围可以从很微小到很巨大。 类型 描述 数据范围 float32 32位浮点型数 最大值：3.40282346638528859811704183484516925440e+38 float64 64位浮点型数 最大值：1.797693134862315708145274237317043567981e+308 很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分： const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 1.2.3 复数 复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。 Go 语言中复数的类型有两种，分别是 complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。 复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。如：1+2i 声明复数的语法格式如下所示： var name complex128 = complex(x, y) 其中 name 为复数的变量名，complex128 为复数的类型，“=” 后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。 如下所示： var cmp complex128 = complex(1, 2) // 复数：1+2i fmt.Println(real(cmp)) // 输出实部 1 fmt.Println(imag(cmp)) // 输出虚部 2 1.3 字符串型 字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，其实，字符串是字节的定长数组。 使用双引号 \"\" 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U`：Unicode 字符 \\\\：反斜杠自身 Go 语言比其他语言更加的灵活，此外，可通过反引号 ` 可以定义多行字符串。（注意：是反引号 ` （键盘上1键左边键），而不是引号 ‘） 多行字符串一般用于内嵌源码和内嵌数据等。 示例如下： package main import \"fmt\" func main() { // 字符串 var str = \"兄弟们！\\n赶紧开始学习Go语言啦。\" fmt.Println(str) var str2 = `第一行 第二行 第三行 ` fmt.Println(str2) } 输出结果如下： 兄弟们！ 赶紧开始学习Go语言啦。 第一行 第二行 第三行 2、派生数据类型 2.1 指针 与 Java 等编程语言不同，Go 语言为程序员提供了控制数据结构指针的能力，但是，并不能进行指针运算。Go语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。 一个指针变量指向了一个值的内存地址。 类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下： var * 例如： var ip *int // 指向整型的指针 指针的使用流程一般为： 定义指针变量。 为指针变量赋值。 访问指针变量中指向地址的值。 示例如下： package main import \"fmt\" func main() { // 指针 var i int = 20 // 声明实际变量 var ip *int // 声明指针变量 ip = &i // 指针变量的存储地址 fmt.Println(\"i变量的地址是: \", &i) // 变量的存储地址 fmt.Println(\"ip变量储存的指针地址: \", ip) // 指针变量的存储地址 fmt.Println(\"*ip变量的值: \", *ip) // 使用指针访问值 } 输出结果如下： i变量的地址是: 0xc00008a000 ip变量储存的指针地址: 0xc00008a000 *ip变量的值: 20 提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。 2.2 数组 数组是具有相同类型的一组已编号且长度固定的数据集合，这种类型可以是任意的基本数据类型，例如整型、字符串，或者自定义类型。 相对于去声明 number0, number1, ..., number99 的变量，使用数组形式 numbers[0], numbers[1] ..., numbers[99] 更加方便且易于扩展。 数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。 声明数组 Go 语言数组声明需要指定元素类型及元素个数，语法格式如下： var [数组长度] 例如，定义一个长度为 5 的 int 类型数组： var intArr [5]int 初始化数组 var intArr = [5]int{1,2,3,4,5} 或者 intArr := [5]int{1,2,3,4,5} 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度： intArr := [...]int{1,2,3,4,5} 如果设置了数组的长度，我们还可以通过指定下标来初始化对应元素： // 将索引为1和3的元素初始化,其他索引的元素将以默认值处理 intArr := [5]int{1:2,3:5} 访问数组元素 数组元素可以通过索引来读取。格式为数组名后加中括号 []，中括号中为索引的值。例如： var i int = intArr[4] 示例如下： package main import \"fmt\" func main() { // 数组 var intArr [10]int // 定义一个int类型数组 var idx int // 遍历数组赋值 for idx = 0; idx 输出结果如下： intArr[0] = 0 intArr[1] = 10 intArr[2] = 20 intArr[3] = 30 intArr[4] = 40 intArr[5] = 50 intArr[6] = 60 intArr[7] = 70 intArr[8] = 80 intArr[9] = 90 2.3 结构体 Go 语言中数组只能存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。 Go 语言中没有类的概念，因此在 Go 中结构体有着更为重要的地位。 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 结构体表示一项记录，比如保存一个人的信息，每个人有以下属性： Name ：姓名 Sex： 性别 Age：年龄 结构体定义 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct { …… } 例如： type Person struct { Name string Sex string Age int } 结构体声明、赋值 定义好一个结构体后，就可以声明结构体为一个变量，并自动初始化为零值，然后可以对其成员赋值，例如： var p Person p.Name = \"xcbeyond\" p.Age = 18 或者，使用结构体字面量声明变量，并初始化为非零值，例如： p := Person { Name: \"xcbeyond\", Sex: \"F\", Age: 18 } 2.4 通道(channel) 通道，是 goroutine 之间的通道。它可以让 goroutine 之间相互通信。（在后续并发章节会详细讲解） 每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。 声明通道 和声明一个变量一样，语法如下： // 声明通道 var chan // 创建通道：如果通道为nil(就是不存在)，就需要先创建通道 = make(chan ) 也可以简化声明为： := make(chan ) 示例如下： package main import \"fmt\" func main() { // 通道 var c chan int if c == nil { fmt.Println(\"通道c是nil的, 不能使用，需要先创建通道。\") c = make(chan int) fmt.Printf(\"c的数据类型是：%T\", c) } } 输出结果如下： 通道c是nil的, 不能使用，需要先创建通道。 c的数据类型是：chan int 2.5 切片(slice) Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 切片定义 使用一个未指定大小的数组来定义切片： var [] 或使用 make() 函数创建切片： var [] = make([] len) 或 := make([] len) 也可以指定容量，其中 capacity 为可选参数： make([]T, length, capacity) 这里的 length 是数组的长度也是切片的初始长度。 切片初始化 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3，其中 cap=len=3： s :=[] int {1,2,3 } 初始化切片 s，是数组 arr 的引用： s := arr[:] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片： s := arr[startIndex:endIndex] 默认 startIndex 时将表示一直到 arr 的最后一个元素： s := arr[startIndex:] 默认 endIndex 时将表示从 arr 的第一个元素开始。 s := arr[:endIndex] 通过切片 s 初始化切片 s1。 s1 := s[startIndex:endIndex] 通过内置函数 make() 初始化切片 s，[]int 标识为其元素类型为 int 的切片： s :=make([]int,len,cap) 2.6 函数 函数是基本的代码块，用于执行一个任务。 Go 语言最少有个 main() 函数。 你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。 函数声明告诉了编译器函数的名称，返回类型，和参数。 Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。 函数定义 Go 语言函数定义格式如下： func function_name( ) { 函数体 } func：函数由 func 开始声明 function_name：函数名称，函数名和参数列表一起构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 示例如下： package main import \"fmt\" func main() { fmt.Print(max(10, 7)) } // 获取两数的最大值 func max(num1, num2 int) int { if num1 > num2 { return num1 } else { return num2 } } 输出结果如下： 10 与其他语言不同的是，Go语言的函数可以返回多个值。 示例如下： package main import \"fmt\" func main() { x, y := swap(\"xcbeyond\", \"Niki\") fmt.Println(x, y) } // 交换两个字符串 func swap(x, y string) (string, string) { return y, x } 输出结果如下： Niki xcbeyond 2.7 接口(interface) Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 2.8 Map Map 是一种无序的键值对的集合。Map 最重要的一点是通过key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 Map定义 可以使用内建函数 make() ，也可以使用 map 关键字来定义 Map： // 声明变量，默认map是nil var map_variable map[key_data_type]value_data_type // 使用make map_variable := make(map[key_data_type]value_data_type) 示例如下： package main import ( \"fmt\" ) func main() { // Map personMap := make(map[string]string) personMap[\"zhangsan\"] = \"张三\" personMap[\"lisi\"] = \"李四\" personMap[\"wanger\"] = \"王二\" personMap[\"zhaowu\"] = \"赵五\" for p := range personMap { fmt.Println(p, \"的中文名是\", personMap[p]) } } 输出结果如下： zhangsan 的中文名是 张三 lisi 的中文名是 李四 wanger 的中文名是 王二 zhaowu 的中文名是 赵五 3、其他 3.1 数据类型转换 面对不同的数据类型，尤其是基本数据类型，在必要的情况下，一个类型的值是可以被转换为另外一个可被转换的类型。 不同于其他语言，Go 语言不存在隐式类型转换，所有的类型转换都必须是显示的转换： 类型B的值 = 类型B(类型A的值) 类型转换只能在定义正确的情况下才能转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。 换言之，类型转换只能从低精度向高精度转换，否则将会存在精度丢失。 示例如下： package main import ( \"fmt\" ) func main() { // 类型转换 var i16 int16 = 10000 i32 := int32(i16) fmt.Print(i32) } 3.2 类型别名 类型别名是 Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 C/C++ 语言中，代码重构升级可以使用宏快速定义一段新的代码，Go 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。 在 Go 1.9 版本之前定义内建类型的代码是这样写的： type byte uint8 type rune int32 而在 Go 1.9 版本之后变为： type byte = uint8 type rune = int32 类型别名定义 定义类型别名的写法为： type TypeAlias = Type TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。 注意：类型别名与类型定义表面上只有一个等号的差异，那么它们之间实际的区别有哪些呢？通过下面的示例代码来理解。 示例如下： package main import \"fmt\" // 定义int类型的变量为NewInt type NewInt int // 定义int类型的别名IntAlias type IntAlias = int func main() { var a NewInt fmt.Printf(\"a type:%T\\n\", a) var a2 IntAlias fmt.Printf(\"a2 type:%T\\n\", a2) } 输出结果如下： a type:main.NewInt a2 type:int 4、小结 本文主要讲解 Go 语言中存在哪些数据类型，让你对所有数据类型有个整体的认识，学会对它们的基本使用（定义、初始化等）。从上面的学习中，你会发现 Go 语言相比其他语言是更加的灵活，弥补了其他语言数据类型的一些缺失、不便等。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/conditions-and-loops.html":{"url":"basics/conditions-and-loops.html","title":"条件和循环","keywords":"","body":"条件和循环 在程序中必然少不了条件语句和循环语句，Go 语言在条件、循环语句方面与其他语言存在一定的差异，本文将针对 Go 语言中条件语句、循环语句的使用，这将会奠定后续复杂程序的基础。 1、条件语句 条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。 下图展示了程序语言中条件语句的结构： 图 3.4.1：条件语句结构 Go 语言提供了以下几种条件判断语句： 语句 描述 if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。 if...else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 switch 语句 switch 语句用于基于不同条件执行不同动作。 select 语句 select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 **注意：Go 没有三目运算符，所以不支持 `? :` 形式的条件判断。** 1.1 if 语句 语法 Go 编程语言中 if 语句的语法如下： if 布尔表达式 { // 在布尔表达式为 true 时执行 } if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。 布尔表达式可以不用 () 括起来，简洁了很多。 流程图如下： 图 3.4.2：if语句流程图 示例 使用 if 判断一个整数的大小，示例如下： package main import \"fmt\" func main() { var a int = 10 if a 输出结果如下： a 小于 20 1.2 if .. else 语句 语法 Go 编程语言中 if...else 语句的语法如下： if 布尔表达式 { // 在布尔表达式为 true 时执行 } else { // 在布尔表达式为 false 时执行 } if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。 流程图如下： 图 3.4.3：if else语句流程图 示例 使用 if else 判断一个整数的大小，示例如下： package main import \"fmt\" func main() { var a int = 30 if a 输出结果如下： a 大于 20 1.3 if 嵌套语句 语法 Go 编程语言中 if...else 语句的语法如下： if 布尔表达式 1 { // 在布尔表达式 1 为 true 时执行 if 布尔表达式 2 { // 在布尔表达式 2 为 true 时执行 } } 此外，也可以在if中嵌套 if..else 语句等条件语句。 示例 package main import \"fmt\" func main() { var a int = 30 var b int = 100 if a == 30 { if b == 100 { fmt.Printf(\"a = %d, b = %d\\n\", a, b) } } } 输出结果如下： a = 30, b = 100 1.4 switch 语句 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下，直到匹配为止。 和其它语言不同的是： switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。 switch 后面变量的类型可以是任何类型，不再局限于常量或整数。 语法 Go 编程语言中 switch 语句的语法如下： switch var1 { case val1: ... case val2: ... default: ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 流程图如下： 图 3.4.4：switch语句流程图 示例 package main import \"fmt\" func main() { var grade string = \"B\" var marks int = 90 switch marks { case 90: grade = \"A\" case 80: grade = \"B\" case 50, 60, 70: grade = \"C\" default: grade = \"D\" } switch { case grade == \"A\": fmt.Printf(\"优秀!\\n\") case grade == \"B\", grade == \"C\": fmt.Printf(\"良好\\n\") case grade == \"D\": fmt.Printf(\"及格\\n\") case grade == \"F\": fmt.Printf(\"不及格\\n\") default: fmt.Printf(\"差\\n\") } fmt.Printf(\"你的等级是 %s\\n\", grade) } 输出结果如下： 优秀! 你的等级是 A 1.5 select 语句 2、循环语句 在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。 以下为大多编程语言循环程序的流程图： 图 3.4.5：循环语句流程 与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构。 Go 语言提供了以下几种类型循环语句： 循环类型 描述 for 循环 重复执行相同逻辑的语句块。for 循环中也可以嵌套一个或多个 for 循环。在实际开发中，嵌套层数不要太深，一般 2 层即可。 for range 循环 能够帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。 在循环过程中，因实际需求需要在适当的条件下推出循环，此时循环控制语句则可以控制循环体内语句的执行过程。 Go 语言支持以下几种循环控制语句： 控制语句 描述 break 语句 经常用于中断当前 for 循环或跳出 switch 语句 continue 语句 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 语句 将控制转移到被标记的语句。 2.1 for 循环 语法 Go 语言 for 循环更加的灵活，有三种形式： for init; condition; post { // 循环体 } 类似于 do while： for condition { // 循环体 } 无限循环： for { // 循环体 } init： 一般为赋值表达式，给控制变量赋初值。 condition： 关系表达式或逻辑表达式，循环控制条件。 post： 一般为赋值表达式，给控制变量增量或减量。 示例 求 1~100 之间的求和，示例如下： package main import \"fmt\" func main() { sum := 0 for i := 1; i 2.2 for range 循环 除了使用经典的三段式循环之外，Go 语言还引入了一个新的关键字 range，用于帮助我们快速遍历数组等集合类型，非常简洁好用，成为了数组遍历的标配。 语法 for k,v := range arr { // 循环体 } k：数组 arr 的索引。 v：数组 arr 对应索引 k 的值。 示例 循环输出一个数组中的所有数据，示例如下： package main import \"fmt\" func main() { arr := []string{\"A\", \"B\", \"C\", \"D\"} for k, v := range arr { fmt.Printf(\"arr[%d]=%s\\n\", k, v) } } 输出结果如下： arr[0]=A arr[1]=B arr[2]=C arr[3]=D 2.3 break 语句 Go 语言中 break 语句用于以下三方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break 在 switch 中在执行一条 case 后跳出语句的作用。 在多重循环中，可以用标号 label 标出想 break 的循环。 语法 break 示例 示例如下： package main import \"fmt\" func main() { var a int = 10 for a 15 { break } } } 输出结果如下： a=10 a=11 a=12 a=13 a=14 a=15 使用多重循环，演示使用标记和不使用标记的区别，示例2如下： package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- break ----\") for i := 1; i 输出结果如下： ---- break ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 ---- break label ---- i: 1 i2: 11 2.4 continue 语句 Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 语法 continue 示例 示例如下： package main import \"fmt\" func main() { var a int = 10 for a 15 { continue } fmt.Printf(\"****\\n\") } } 输出结果如下： a=10 **** a=11 **** a=12 **** a=13 **** a=14 **** a=15 a=16 a=17 a=18 a=19 2.5 goto 语句 Go 语言的 goto 语句可以无条件地跳转到任意指定位置。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。（这与 Java 语言中一样，不推荐使用。） 语法 goto label .. . label: statement 示例 示例如下： package main import \"fmt\" func main() { var b int = 10 for b 15 { goto print } } print: fmt.Printf(\"****\\n\") } 输出结果如下： b=10 b=11 b=12 b=13 b=14 b=15 **** Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "}}