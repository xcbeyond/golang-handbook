{"./":{"url":"./","title":"序言","keywords":"","body":"序言 “Go will be the server language of the future.” — Tobias Lütke, Shopify 在过去几年，崛起了一门新的语言：Go 或者 GoLang。没有什么比一门新的编程语言更令开发者兴奋了，不是么? 图 1.1.1：golang 目前一些开源社区，纷纷采用 Go 语言开发了许多平台、框架等，如：Docker、Kubernetes等，甚至逐步从其它语言（如：C、Java 等）转换到了 Go，相信这一点你已经体会到了。当您在看一些开源代码时，全是 Go 语言编写的，你该咋办呢？ 此外，伴随着近两年来云原生技术的发展迅猛，Go 语言作为新生代的编译型编程语言，凭借语法简单、高并发性能良好和编译速度快等特点，成为了云原生技术落地实践的绝妙利器。云原生的到来，这也将迫使您不得不多学习一门新语言了。 因此，从今天开始从零开始学 Go 语言，一方面是督促自己不断前行且学习新的知识，另一方面是分享给读者，希望与大家一起进步。该电子书将从零基础开始，以通俗易懂的方式一起学习、分享 Go 语言的学习历程，不断归档总结，且看且珍惜吧，加油！ 适合人群： 编程爱好者 Go语言初学者 学习目标： 帮助 Go 语言小白快速学习 Go 语言基础知识，从不了解到了解，到会写 Go 语言程序，到入门，直到精通，作为Go语言系列全教程。 废话不多说，奥力给！ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 17:16:25 "},"introduction/golang-introduce.html":{"url":"introduction/golang-introduce.html","title":"Go语言介绍","keywords":"","body":"Go语言介绍 1、Go语言介绍 Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. “Go 是一种开源的程序设计语言，它意在使得人们能够方便地构建简单、可靠、高效的软件。”（来自Go 官网golang.org的定义） Go 语言，又称为 Golang，在 2007 年 9 月形成构思，并于 2009 年 11 月发布，其发明人是 Google 的 Robert Griesemer, Rob Pike 和 Ken Thompson。该语言其及配套工具集使得编译和执行既富有表达力又高效，而且使得程序员能够轻松写出可靠、健壮的程序。 Go 的吉祥物是金花鼠（gordon），并将其作为 logo，如下图所示： Go 是从 2007 年末由 Robert Griesemer, Rob Pike, Ken Thompson 主持开发，后来还加入了 Ian Lance Taylor, Russ Cox 等人，并最终于 2009 年 11 月开源，在 2012 年早些时候发布了 Go 1 稳定版本。现在 Go 的开发已经是完全开放的，并且拥有一个活跃的社区。 1.1 Go 的起源 编程语言的演化跟生物物种的演化类似，成功的语言会繁衍后代，这些后代语言会从它们的祖先那里汲取各种优点。有时候，语言间的“混血”会产生异常强大的力量；在一些罕见情况下，某个重大的语言特性也可能凭空出现而无先例。通过观察语言间的影响，我们可以学到不少知识，比如语言为什么会变成这个样子，以及它适合用于哪些环境等等。 下图展示了有哪些早期的编程语言对 Go 语言的设计产生了重要影响。 图 2.1.1：Go语言的演进过程 Go 有时会称为“类 C 语言”，或者是“21 世纪的 C 语言”。从 C 中，Go 继承了相似的表达式语法、控制流结构、基本数据类型、按值调用的形参传递和指针，但比这些更重要的是，继承了C所强调的要点：程序要编译成高效的机器码，并自然地与所处的操作系统提供的抽象机制相配合。 但是在 Go 语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有 Oberon 语言的面向对象特性所提供的方法的声明语法等。 Go 语言的另一支祖先，带来了 Go 语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献 顺序通信进程 （ communicating sequential processes ，缩写为CSP。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。 接下来，Rob Pike 和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的Newsqueak语言，提供了类似 C 语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak 是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在 Newsqueak 语言中管道是动态创建的，属于第一类值, 可以保存到变量中。 在 Plan9 操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在 Alef 之后还有一个叫Limbo的编程语言，Go 语言从其中借鉴了很多特性。 具体请参考 Pike 的讲稿：http://talks.golang.org/2012/concurrency.slide#9 ） Go 语言的其他的一些特性零散地来自于其他一些编程语言；比如 iota 语法是从APL)语言借鉴，词法作用域与嵌套函数来自于Scheme)语言（和其他很多语言）。当然，我们也可以从 Go 中发现很多创新的设计。比如 Go 语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有 Go 语言新发明的 defer 语句。 1.2 Go 的特点 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 1.3 Go 的用途 其它语言能够实现的系统，Go 语言都能实现。 目前，Go 主要应用在下面这些系统： 服务器编程，以前你如果使用 C 或者 C++ 做的那些事情，用 Go 来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统、数据库代理器等，比如 Etcd。 网络编程，这一块目前应用最广，包括 Web 应用、API 应用、下载应用，而且 Go 内置的 net/http 包基本上把我们平常用到的网络功能都实现了。 数据库，前一段时间 Google 开发的 Groupcache，Couchbase 的部分组件，Tidb，Cockroachdb，Influxdb 等。 云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的Apcera云平台。 云原生技术，比如docker、Kubernetes等。 1.4 Go 的美貌 说了这么多，Go 程序到底长啥样？我们先睹为快，一看美貌！ 来来来，以 hello.go 为例看看它长啥样。（Go 语言源文件的扩展是 .go） package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 2、为什么我们要学习Go？ 就我而言，目前主要从事微服务方面的产品研发，之前一直使用Java语言作为核心编程语言，但随着市场的变化，Java有时变得力不从心（一些轻量级的功能模块实现时，Java却显得有些笨重）。此外，为迎接云原生技术的到来，学习Go成为了必然。 对于你而言，为什么要学习Go呢？下面我参考知乎和网上大神的答案，谈谈Go语言的优势。 Go 语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 C/C++ 的问题 开发效率低，对开发者要求高；libc 只向后兼容，运维难度偏大。 Lua/Python 的问题 动态语言，缺少编译过程，低级错误频出；缺少有效的性能分析及调试工具。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/install.html":{"url":"introduction/install.html","title":"开发环境搭建","keywords":"","body":"开发环境搭建 1、Go语言环境安装 1.1 开发包获取 Go 语言支持以下系统： Windows Linux Mac：也称为 Darwin FreeBSD 开发包下载地址为：https://golang.org/dl 如果打不开可以使用这个地址：https://golang.google.cn/dl 根据你的系统，选择下载对应的开发包。 图 2.2.1：Go-installer-package 以 Windows 系统为例，下载 Windows 的安装包 go1.16.windows-amd64.msi，下载地址：https://golang.google.cn/doc/install?download=go1.16.windows-amd64.msi 1.2 开发包安装 （1）安装开发包。 双击下载的安装包 go1.16.windows-amd64.msi，一步步安装即可。 默认情况下，会安装在 C:\\Program Files\\Go 目录下。（不同版本会存在差异，以实际为准！） （2）配置 Go 环境变量。 默认情况下，安装完开发包会自动配置 Go 环境变量，如若未配置或配置不符合自己需求（GOPATH 可按照自己的实际情况配置），则安装下面的配置方法配置或进行调整。 根据 Windows 系统在查找可执行程序的原理，可以将 Go 所在路径定义到环境变量中，让系统帮我们去找到运行执行的程序，这样任何目录都可以执行 go 指令。配置的环境变量如下所示： 环境变量 说明 Path 添加 Go 开发包的 /bin 目录，如：C:\\Program Files\\Go\\bin GOPATH 工作目录，设置 Go 项目的工作路径，可根据自我喜好设置。 右键“我的电脑”-> 属性 -> 高级系统设置 -> 高级 -> 系统变量： 图 2.2.2：环境变量设置 添加的环境变量如下： Path：C:\\Program Files\\Go\\bin 图 2.2.3：配置环境变量Path GOPATH：E:\\github\\golangLearning，自定义目录，作为后续 Go 工程目录。 （3）环境检验。 打开 cmd 命令行，执行 go version，检查是否安装成功并生效。 图 2.2.4：go-version执行结果 2、IDE 安装 2.1 IDE 工具 常用的 Go 开发 IDE 如下所示： Visual Studio Code（简称 VSCode） 微软的产品，一个运行于 Mac OS、Windows 和 Linux 之上的工具，默认提供 Go 语言的语法高亮。安装 Go 语言插件，还可以支持智能提示，编译运行等功能。 Sublime Text 可以免费试用，默认也支持Go代码语法高亮，只是保存次数达到一定数量后需要购买。 Vim 它是从 vi（Linux）发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能非常丰富。 Emacs 它不仅仅是一个编辑器，因为功能强大，可称为集成开发环境。 Eclipse IDE 工具 开源免费，并提供 GoEclipse 插件。 LiteIDE LiteIDE 是一款专门为 Go 语言开发的跨平台轻量级集成开发环境（IDE），是国人开发的。 JetBrains公司的产品 GoLand、PhpStrom、WebStrom 和 PyCharm 等 IDE 工具，都需要安装 Go 插件。 Go 语言的 IDE 工具很多，可根据自我喜好自行选择，不做强制要求。 （建议大家先选择使用 VSCode，这样能让你更好地理解 Go 语言、基本语法和关键字等。等熟悉 Go 的语法后，再切换到自己顺手的 IDE 即可。） 2.2 安装 VSCode 下载地址：https://code.visualstudio.com/ 图 2.2.5：VSCode下载页面 下载页面可以选择不同版本供大家下载。 我选择了 Windows x64 版本下载，并直接安装即可。 2.3 VSCode 配置 Go 语言插件 （1）首先安装 Go 语言插件： 图 2.2.6：VSCode安装Go语言插件 （2）配置 Go 开发环境包 VSCode 中，快捷键 ctrl+shift+p 打开，输入 go:install： 图 2.2.7：VSCode插件安装go install 并选中 Go:Install/Update Tools 回车，并全部勾选，确认： 图 2.2.8：VSCode插件安装go install Tools environment: GOPATH=E:\\github\\golangLearning Installing 9 tools at E:\\github\\golangLearning\\bin in module mode. gopkgs go-outline gotests gomodifytags impl goplay dlv golint gopls 省略…… Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (E:\\github\\golangLearning\\bin\\gopkgs.exe) SUCCEEDED Installing github.com/ramya-rao-a/go-outline (E:\\github\\golangLearning\\bin\\go-outline.exe) SUCCEEDED 省略…… All tools successfully installed. You are ready to Go :). 2.4 Go 语言程序快速运行 （1）VSCode 打开刚刚创建的 GOPATH 工程目录。 （2）创建一个新的文件 test.go，编写 Hello, World! Go 程序，代码如下： package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 保存文件后，VSCode 会自动检测到可能需要安装的扩展包或插件，此时我们会看到右下角有弹框提示，如下所示。此时我们暂时忽略，无需安装。 图 2.2.9：VSCode安装Go扩展包 （3）快速运行。 VSCode 中 “Terminal” -> New Terminal，执行 go run test.go 命令直接运行 test.go 程序，结果如下： （实际环境是需要先编译(go build)后运行。go run 命令的执行时间较长，是因为其中包含编译过程。） 图 2.2.10：go run示例 到此，Go 语言开发环境搭建完毕！ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/first-golang-program.html":{"url":"introduction/first-golang-program.html","title":"编写第一个Go程序","keywords":"","body":"编写第一个 Go 程序 在开始 Go 语言的基本语法、函数和高级特性等之前，让我们先编写第一个 Go 程序 “Hello World” 开始，来了解 Go 语言最简单程序的结构吧，看看 Go 程序应该包括哪些部分，每部分都位于什么位置，Go 语言究竟是如何执行的。 我们依然从永恒的 “hello,world” 程序开始，hello.go 源代码如下： package main import \"fmt\" func main() { // \"Hello World!\" Go语言程序 fmt.Println(\"Hello World!\") } 让我们来看下以上程序的各个部分： 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。 package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import fmt 告诉 Go 编译器这个程序需要使用 fmt 包中的函数或其他元素，fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数（入口函数）。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数），等同于 Java 中的 public static void main(String[] agrs)。 下一行 // 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。（与其他语言相同） 下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n 换行。使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台，后续会单独讲解 fmt 包相关的内容。 1、Go语言结构 从上面的 hello world 程序可以看出，一个完整 Go 语言的程序结构由以下几部分组成： 包声明 引入包 函数 变量 语句 & 表达式 注释 2、执行流程 Go程序源文件是以 .go 作为后缀的文件，有两种执行流程： 1、将源文件先编译成可执行的二进制文件，再运行。 编译源代码：go build 命令，生成可执行文件。 运行可执行文件：直接运行可执行程序文件。 常用于在 Go 编译环境上编译生成可执行的二进制文件，并将可执行的二进制文件部署在任何没有 Go 编译环境的机器上。 图 2.3.1：go build运行流程 2、直接对源文件执行 go run 命令。 常用于开发环境测试使用。（go run 必须依赖 go 开发编译环境） 图 2.3.2：go run运行流程 3、开发注意事项 Go 源文件以 “go” 为扩展名，如：hello.go。 Go 应用程序的执行入口是 main() 函数。 Go 语言严格区分大小写。 Go 方法是由一条条语句构成，每个语句后不需要分号 ; 结束（实际上 Go 语言会自动在每行后加分号），这也体现了 Go 语言的简洁性。 Go 编译器是一行行编译的，因此我们一行就写一条语句，不能把多条语句写在同一行，否则报错。 Go 语言定义变量或者 import 的包如果没有使用到，则代码不能编译通过。 大括号都是成对出现的。 大括号 { 不能单独放在一行。如： package main import \"fmt\" func main() { // 错误，{不能单独成行 fmt.Println(\"Hello World!\") } Go 语言有内置 gofmt 工具，能够自动整理代码多余的空白、变量名称对齐、并将对齐空格转换成 Tab。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"introduction/goproxy.html":{"url":"introduction/goproxy.html","title":"Go代理goproxy","keywords":"","body":"Go 代理 goproxy 在逐步编写 Go 程序时，会涉及使用到第三方提供的Go依赖包，如：github.com/spf13/cobra，在国内使用 go get 命令安装时经常会出现 timeout 等问题，实在让人头疼。大家都知道，在国内网络环境下，想要解决这种问题，只有掌握科学上网才能彻底解决。但是xx上网却是需要花费额外成本的，那该怎么办呢？ 本文将会介绍一种Go代理 goproxy 的方式来解决上述问题，让你既不花钱，又能快速下载安装。 1、goproxy.cn 介绍 Go 的 1.11 版本以后可以设置环境变量 GOPROXY，来设置代理，以加速下载。目前国内使用最多的是 goproxy.cn，号称中国最可靠的Go模块代理。 图 2.4.1：goproxy.cn 它有以下特点： 极速下载： 我们正在使用七牛云 CDN 在全球范围内加速我们的服务，并且我们没有设置任何带宽限制。凭借着数以千计的 CDN 节点和 40Gbps+ 的单节点带宽，你将被赋予一个以极快的速度下载模块版本的能力。 没有限制： 我们不但没有设置带宽限制。更进一步地，我们还没有设置任何速率限制。这意味着你可以在任何场景下使用我们的服务，例如 CI/CD。你甚至可以像 goproxy.baidu.com 一样将我们的服务用作上游代理。 功能齐全： 我们一直在使用最新的 Go 版本，甚至是不稳定版本。因为我们提供了最前沿的功能支持。特别地，我们支持代理默认的校验和数据库 sum.golang.org。你不需要做任何额外的事情，它就可以工作。 数据可视： 为了使大家可以更好地了解我们的服务中所有模块的活跃度，我们推出了 Go 模块代理世界中的首个统计数据 API。通过得体的 RESTful API 设计，你将能够轻松地查询我们服务中所有模块版本的统计数据。 2、goproxy.cn 配置 推荐在 Go 1.13 以上版本使用。 打开你的终端执行下面命令： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct macOS 或 Linux： export GO111MODULE=on export GOPROXY=https://goproxy.cn 或者 echo \"export GO111MODULE=on\" >> ~/.profile echo \"export GOPROXY=https://goproxy.cn\" >> ~/.profile source ~/.profile Windows： 打开 cmd 命令行，执行： C:\\> $env:GO111MODULE = \"on\" C:\\> $env:GOPROXY = \"https://goproxy.cn\" 3、小结 有上述 goproxy 代理的设置，go get 命令下载将会变得很快，轻松解决了 timeout 问题。此外，也可以通过国外 goproxy.io 代理完成加速，配置方法和 goproxy.cn 完全一样。 参考文章： https://goproxy.cn https://www.goproxy.io/zh/ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-14 22:55:52 "},"basics/basic-syntax.html":{"url":"basics/basic-syntax.html","title":"基础语法","keywords":"","body":"基础语法 与其他编程语言一样，Go 语言项目（大程序）都是从基本组件和基本语法编写而成。上一章节我们已经了解了 Go 语言的样子，本章节我们将学习 Go 语言的基础语法，也将是接下来所有 Go 程序中不可或缺的部分。 1、命名规则 Go 中类型、变量、常量、语句标签、包和函数的命名都遵循一个简单的规则：命名的开头是一个字母或下划线而不能是数字，后面可以跟任意数量的字符、数字和下划线，并区分大小写。 如, xcbeyond 和 xcBeyond 是不同的标识符。 以下是有效的标识符： mahesh kumar abc move_name a_123 myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab：以数字开头 case：Go 语言的关键字 a+b：运算符是不允许的 2、关键字 Go 语言和其他语言一样，也有一些关键词供程序使用。Go 中有 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 3、注释 注释，是为了增强代码的可读性，但不参与程序的一切功能，不会被编译。每个程序都应该在适当的位置添加注释，用于功能、实现、标注等说明，如果你不想不其他人唾弃，请一定养成编写注释的习惯，注释和代码同样重要。 Go 语言的注释主要分为两类： 单行注释：你可以在任何地方使用以 // 开头的单行注释，是最常见的注释形式。 多行注释：也叫块注释，以 /* 开头，并以 */ 结尾。 如下所示： package main import \"fmt\" func main() { // \"Hello World!\" Go语言程序 fmt.Println(\"Hello World!\") // 这是一个单行注释 /* 这是一个多行注释 by xcbeyond */ } 4、行分隔符 在 Go 程序中，一行代表一个语句结束。每个语句不需要像 Java 等其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： fmt.Println(\"Hello, World!\") fmt.Println(\"Hello, xcbeyond!\") 5、字符串输出 Go 语言的字符串输出可以通过函数 fmt.Println 或 fmt.Print 实现，fmt.Println 会输出后换行，类似于 Java 语言中的 System.out.println 和 System.out.print。 如下所示： package main import \"fmt\" func main() { // 输出后换行 fmt.Println(\"xcbeyond，帅么？\") // 输出后不换行 fmt.Print(\"帅!\") fmt.Print(\"太帅了!\") } 输出结果： xcbeyond，帅么？ 帅!太帅了! 此外，字符串输出还可以进行格式化输出，后续章节会进行介绍。 6、字符串拼接 Go 语言的字符串拼接最常用的方法是通过 + 实现： package main import \"fmt\" func main() { fmt.Println(\"xc\" + \"beyond\") } 输出结果： xcbeyond + 实现拼接，会产生一个新的字符串对效率有所影响。除此之外，还可以借助函数 fmt.Sprintf、strings.Join、buffer.WriteString 等实现，后续字符串章节会详细介绍。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/variables.html":{"url":"basics/variables.html","title":"变量","keywords":"","body":"变量 变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。 Go 语言是静态类型语言，因此变量（variable）是有明确类型的，编译器也会检查变量类型的正确性。 变量可以通过变量名访问。 Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 1、变量的声明 声明变量的一般形式是使用 var 关键字： var name type 其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。 还可以一次声明多个类型相同的变量： var name1,name2,name3 type 需要注意的是，Go 语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b; 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型： var a, b *int 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。 示例如下： package main import \"fmt\" func main() { var a,b int fmt.Println(a,b) } 输出结果如下： 0 0 变量的声明有多种形式，整理归纳如下。 1.1 标准声明格式 Go 语言的变量声明的标准格式如下： var 变量名 变量类型 或 var 变量名1,变量名2 变量类型 变量声明以关键字 var 开头，后置变量类型，行尾无须分号。 如果没有初始化，则变量默认为零值。（零值就是变量没有做初始化时系统默认设置的值。） var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。 示例如下： package main import \"fmt\" func main() { // 声明一个没有初始化的int类型变量，默认为零值0 var a int fmt.Println(a) // 声明一个没有初始化的bool类型变量，默认为零值false var b bool fmt.Println(b) } 输出结果如下： 0 false 1.2 根据值自行判定变量类型 var 变量名 = 变量值 示例如下： package main import \"fmt\" func main() { var c = true fmt.Println(c) } 输出结果如下： true 1.3 短变量声明 在函数中，一种称为短变量声明的可选形式可以用来声明和初始化局部变量。格式如下： 变量名 := 变量值 这里省略了关键字 var，变量名的类型由变量值的类型决定，变量值可以是任何函数或表达式计算的结果值。 因其短小、灵活，故而在局部变量的声明和初始化中主要使用。 短变量声明有以下注意点： 定义变量，同时显式初始化。 不能直接提供数据类型。 只能用在函数内部。 := 表示声明，而 = 表示赋值。 := 左侧如果是已声明的变量，就会产生编译错误。如： var intVal int intVal := 1 // 会产生编译错误 示例如下： package main import \"fmt\" func main() { // 短变量声明 d := \"xcbeyond\" fmt.Println(d) } 输出结果如下： xcbeyond 1.4 批量声明 觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法： var ( a int b string c float64 ) 使用关键字 var 和括号，可以将一组变量定义放在一起。 示例如下： package main import \"fmt\" func main() { // 批量声明 var ( e int f string g float64 ) fmt.Println(e,f,g) } 输出结果如下： 0 0 2、变量的初始化 变量初始化标准格式如下： var 变量名 类型 = 变量值 如： var i int = 100 i 为变量名，类型为 int，i 的初始值为 100。 上面代码中，100 和 int 同为 int 类型，int 可以认为是冗余信息，因此可以进一步简化初始化的写法。 在标准格式的基础上，将 类型 int 省略后，编译器会尝试根据等号右边的变量值推导出变量的类型。如： var i = 100 短变量声明并初始化，如： i := 100 这是 Go 语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。 3、变量的多重赋值 赋值是用来更新变量所指的值，它最简单的形式由赋值符 =，以及符号左边的变量和右边的表达式组成。 x = 1 person.name = \"xcbeyond\" count[x] = count[x] * 5 另一种形式的赋值是多重赋值，它允许几个变量一次性被赋值。 在 Go 语言语法中，变量初始化和变量赋值是两个不同的概念，Go 语言的变量赋值与其他语言一样，但是 Go 语言提供了其他程序员期待已久的多重赋值功能，可以实现变量交换。多重赋值让 Go 语言比其他语言减少了代码量。 以简单的算法交换变量为例，传统写法如下所示： var a int = 10 var b int = 20 var tmp int tmp = a a = b b = t fmt.Println(a, b) 新定义的变量 tmp 是需要内存的，于是有人设计了新的算法来取代中间变量，其中一种写法如下所示： var a int = 10 var b int = 20 a = a ^ b b = b ^ a a = a ^ b fmt.Println(a, b) Go 语言有了多重赋值功能，则简单写法如下所示： var a int = 10 var b int = 20 b, a = a, b fmt.Println(a, b) 从以上例子来看，Go 语言的写法明显简洁了许多，需要注意的是，多重赋值时，左值和右值按照从左到右的顺序赋值。这种方法在错误处理和函数当中会大量使用。 4、匿名变量 在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。 匿名变量的特点是一个下画线 _，_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。 例如，我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。在 Go 中这种情况可以通过结合使用多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅。 假设 GetName() 函数的定义如下，它返回 3 个值，分别为 firstName、lastName 和 nickName，若只想获得 nickName，则可以用如下方式编写： package main import \"fmt\" func main() { // 匿名变量 firstName, _, _ := getName() _, lastName, _ := getName() _, _, nickName := getName() fmt.Println(firstName, lastName, nickName) } func getName() (firstName, lastName, nickName string) { return \"X\", \"C\", \"xcbeyond\" } 输出结果如下： X C xcbeyond 这种用法可以让代码非常清晰，基本上屏蔽掉了可能混淆代码阅读者视线的内容，从而大幅降低沟通的复杂度和代码维护的难度。 匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。 5、变量的作用域 一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。 了解变量的作用域对我们学习Go语言来说是比较重要的，因为Go语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。 根据变量定义位置的不同，可以分为以下三个类型： 局部变量：函数内定义的变量。 全局变量：函数外定义的变量。 形式参数：函数定义中的变量。 下面就来分别介绍一下。 5.1 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。 局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。 main() 函数中使用到了局部变量 a、b、c，示例如下： package main import \"fmt\" func main() { // 声明局部变量a和b并赋值 var a int = 3 var b int = 4 // 声明局部变量c.并计算a和b的和 c := a + b fmt.Printf(\"a = %d, b = %d, c = %d\\n\", a, b, c) } 输出结果如下： a = 3, b = 4, c = 7 5.2 全局变量 在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用 import 关键字引入全局变量所在的源文件之后才能使用这个全局变量。 全局变量声明必须以 var 关键字定义，如果想要在外部包中使用全局变量的首字母必须大写。 定义全局变量 c，示例如下： package main import \"fmt\" // 声明全局变量 var c int func main() { //声明局部变量 var a, b int //初始化参数 a = 3 b = 4 c = a + b fmt.Printf(\"a = %d, b = %d, c = %d\\n\", a, b, c) } 输出结果如下： a = 3, b = 4, c = 7 Go 语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。 5.3 形式参数 在定义函数时，函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。 形式参数会作为函数的局部变量来使用。 函数 sum(a, b int) 定义了形式参数 a、b，示例如下： package main import \"fmt\" func main() { sum := sum(1,3) fmt.Println(sum) } // 两数求和 func sum(a, b int) int{ num := a + b return num } 输出结果如下： 4 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/data-types.html":{"url":"basics/data-types.html","title":"数据类型","keywords":"","body":"数据类型 Go 语言是一种静态类型的编程语言，在 Go 编程语言中，数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。编译器在进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。 Go 语言按类别有以下几种数据类型： 图 3.3.1：Go语言数据类型 下面将针对各种数据类型的使用展开详细的说明。 1、基本数据类型 1.1 布尔型 布尔类型的值只有两种：true 或 false。在if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 等比较操作也会产生布尔型的值。 一元操作符 ! 对应逻辑非操作，因此 !true 的值为 false，更复杂一些的写法是 (!true==false) == true，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示 x==true。 var a = 10 fmt.Println(a == 10) // true fmt.Println(a == 5) // false fmt.Println(a != 10) // false fmt.Println(a != 5) // true Go 语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。 var a = 10 fmt.Println(a == true) // cannot use true (type untyped bool) as type int 布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的： s != \"\" && s[0] == 'x' Go 语言中不允许将整型强制转换为布尔型，代码如下： var n bool fmt.Println(int(n) * 2) // cannot convert n (type bool) to type int 1.2 数值型 Go 语言的数值类型分为以下几种：整数、浮点数、复数。其中每一种都包含了不同大小的数值类型，例如有符号整数包含 int8、int16、int32、int64 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。本小节我们主要介绍一下数值类型。 1.2.1 整型 Go 语言也是基于架构的类型，同时提供了有符号和无符号的整数类型，具体如下： 类型 字节 描述 数据范围 uint8 1 无符号8位整型 0 ~ 255（28-1） uint16 2 无符号16位整型 0 ~ 65535（216-1） uint32 4 无符号32位整型 0 ~ 232-1 uint64 8 无符号64位整型 0 ~ 264-1 int8 1 有符号8位整型 -128（2-7-1） ~ 127（27-1） int16 2 有符号16位整型 -32768（2-15-1） ~ 65535（215-1） int32 4 有符号32位整型 2-31-1 ~ 231-1 int64 8 有符号64位整型 2-63-1 ~ 263-1 int 4或8 有符号32或64位整型 取决于编译器和计算机硬件 uint 4或8 无符号32或64位整型 取决于编译器和计算机硬件 uintptr 4或8 用于存放一个指针 取决于编译器和计算机硬件 有符号：用最高位表示符号（正或负），其余位表示数值大小。 无符号：所有位都用于表示数的大小。 1 字节 = 8 位 大多数情况下，我们只需要 int 一种整型即可，它可以用于循环计数器（for 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 int 类型的处理速度也是最快的。 1.2.2 浮点型 Go 语言提供了两种精度的浮点数：float32 和 float64，这些浮点数类型的取值范围可以从很微小到很巨大。 类型 描述 数据范围 float32 32位浮点型数 最大值：3.40282346638528859811704183484516925440e+38 float64 64位浮点型数 最大值：1.797693134862315708145274237317043567981e+308 很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分： const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 1.2.3 复数 复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。 Go 语言中复数的类型有两种，分别是 complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。 复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。如：1+2i 声明复数的语法格式如下所示： var name complex128 = complex(x, y) 其中 name 为复数的变量名，complex128 为复数的类型，“=” 后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。 如下所示： var cmp complex128 = complex(1, 2) // 复数：1+2i fmt.Println(real(cmp)) // 输出实部 1 fmt.Println(imag(cmp)) // 输出虚部 2 1.3 字符串型 字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，其实，字符串是字节的定长数组。 使用双引号 \"\" 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U`：Unicode 字符 \\\\：反斜杠自身 Go 语言比其他语言更加的灵活，此外，可通过反引号 ` 可以定义多行字符串。（注意：是反引号 ` （键盘上1键左边键），而不是引号 ‘） 多行字符串一般用于内嵌源码和内嵌数据等。 示例如下： package main import \"fmt\" func main() { // 字符串 var str = \"兄弟们！\\n赶紧开始学习Go语言啦。\" fmt.Println(str) var str2 = `第一行 第二行 第三行 ` fmt.Println(str2) } 输出结果如下： 兄弟们！ 赶紧开始学习Go语言啦。 第一行 第二行 第三行 2、派生数据类型 2.1 指针 与 Java 等编程语言不同，Go 语言为程序员提供了控制数据结构指针的能力，但是，并不能进行指针运算。Go语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。 一个指针变量指向了一个值的内存地址。 类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下： var * 例如： var ip *int // 指向整型的指针 指针的使用流程一般为： 定义指针变量。 为指针变量赋值。 访问指针变量中指向地址的值。 示例如下： package main import \"fmt\" func main() { // 指针 var i int = 20 // 声明实际变量 var ip *int // 声明指针变量 ip = &i // 指针变量的存储地址 fmt.Println(\"i变量的地址是: \", &i) // 变量的存储地址 fmt.Println(\"ip变量储存的指针地址: \", ip) // 指针变量的存储地址 fmt.Println(\"*ip变量的值: \", *ip) // 使用指针访问值 } 输出结果如下： i变量的地址是: 0xc00008a000 ip变量储存的指针地址: 0xc00008a000 *ip变量的值: 20 提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。 2.2 数组 数组是具有相同类型的一组已编号且长度固定的数据集合，这种类型可以是任意的基本数据类型，例如整型、字符串，或者自定义类型。 相对于去声明 number0, number1, ..., number99 的变量，使用数组形式 numbers[0], numbers[1] ..., numbers[99] 更加方便且易于扩展。 数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。 声明数组 Go 语言数组声明需要指定元素类型及元素个数，语法格式如下： var [数组长度] 例如，定义一个长度为 5 的 int 类型数组： var intArr [5]int 初始化数组 var intArr = [5]int{1,2,3,4,5} 或者 intArr := [5]int{1,2,3,4,5} 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度： intArr := [...]int{1,2,3,4,5} 如果设置了数组的长度，我们还可以通过指定下标来初始化对应元素： // 将索引为1和3的元素初始化,其他索引的元素将以默认值处理 intArr := [5]int{1:2,3:5} 访问数组元素 数组元素可以通过索引来读取。格式为数组名后加中括号 []，中括号中为索引的值。例如： var i int = intArr[4] 示例如下： package main import \"fmt\" func main() { // 数组 var intArr [10]int // 定义一个int类型数组 var idx int // 遍历数组赋值 for idx = 0; idx 输出结果如下： intArr[0] = 0 intArr[1] = 10 intArr[2] = 20 intArr[3] = 30 intArr[4] = 40 intArr[5] = 50 intArr[6] = 60 intArr[7] = 70 intArr[8] = 80 intArr[9] = 90 2.3 结构体 Go 语言中数组只能存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。 Go 语言中没有类的概念，因此在 Go 中结构体有着更为重要的地位。 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 结构体表示一项记录，比如保存一个人的信息，每个人有以下属性： Name ：姓名 Sex： 性别 Age：年龄 结构体定义 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct { …… } 例如： type Person struct { Name string Sex string Age int } 结构体声明、赋值 定义好一个结构体后，就可以声明结构体为一个变量，并自动初始化为零值，然后可以对其成员赋值，例如： var p Person p.Name = \"xcbeyond\" p.Age = 18 或者，使用结构体字面量声明变量，并初始化为非零值，例如： p := Person { Name: \"xcbeyond\", Sex: \"F\", Age: 18 } 2.4 通道(channel) 通道，是 goroutine 之间的通道。它可以让 goroutine 之间相互通信。（在后续并发章节会详细讲解） 每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。 声明通道 和声明一个变量一样，语法如下： // 声明通道 var chan // 创建通道：如果通道为nil(就是不存在)，就需要先创建通道 = make(chan ) 也可以简化声明为： := make(chan ) 示例如下： package main import \"fmt\" func main() { // 通道 var c chan int if c == nil { fmt.Println(\"通道c是nil的, 不能使用，需要先创建通道。\") c = make(chan int) fmt.Printf(\"c的数据类型是：%T\", c) } } 输出结果如下： 通道c是nil的, 不能使用，需要先创建通道。 c的数据类型是：chan int 2.5 切片(slice) Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 切片定义 使用一个未指定大小的数组来定义切片： var [] 或使用 make() 函数创建切片： var [] = make([] len) 或 := make([] len) 也可以指定容量，其中 capacity 为可选参数： make([]T, length, capacity) 这里的 length 是数组的长度也是切片的初始长度。 切片初始化 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3，其中 cap=len=3： s :=[] int {1,2,3 } 初始化切片 s，是数组 arr 的引用： s := arr[:] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片： s := arr[startIndex:endIndex] 默认 startIndex 时将表示一直到 arr 的最后一个元素： s := arr[startIndex:] 默认 endIndex 时将表示从 arr 的第一个元素开始。 s := arr[:endIndex] 通过切片 s 初始化切片 s1。 s1 := s[startIndex:endIndex] 通过内置函数 make() 初始化切片 s，[]int 标识为其元素类型为 int 的切片： s :=make([]int,len,cap) 2.6 函数 函数是基本的代码块，用于执行一个任务。 Go 语言最少有个 main() 函数。 你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。 函数声明告诉了编译器函数的名称，返回类型，和参数。 Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。 函数定义 Go 语言函数定义格式如下： func function_name( ) { 函数体 } func：函数由 func 开始声明 function_name：函数名称，函数名和参数列表一起构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 示例如下： package main import \"fmt\" func main() { fmt.Print(max(10, 7)) } // 获取两数的最大值 func max(num1, num2 int) int { if num1 > num2 { return num1 } else { return num2 } } 输出结果如下： 10 与其他语言不同的是，Go语言的函数可以返回多个值。 示例如下： package main import \"fmt\" func main() { x, y := swap(\"xcbeyond\", \"Niki\") fmt.Println(x, y) } // 交换两个字符串 func swap(x, y string) (string, string) { return y, x } 输出结果如下： Niki xcbeyond 2.7 接口(interface) Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 2.8 Map Map 是一种无序的键值对的集合。Map 最重要的一点是通过key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 Map定义 可以使用内建函数 make() ，也可以使用 map 关键字来定义 Map： // 声明变量，默认map是nil var map_variable map[key_data_type]value_data_type // 使用make map_variable := make(map[key_data_type]value_data_type) 示例如下： package main import ( \"fmt\" ) func main() { // Map personMap := make(map[string]string) personMap[\"zhangsan\"] = \"张三\" personMap[\"lisi\"] = \"李四\" personMap[\"wanger\"] = \"王二\" personMap[\"zhaowu\"] = \"赵五\" for p := range personMap { fmt.Println(p, \"的中文名是\", personMap[p]) } } 输出结果如下： zhangsan 的中文名是 张三 lisi 的中文名是 李四 wanger 的中文名是 王二 zhaowu 的中文名是 赵五 3、其他 3.1 数据类型转换 面对不同的数据类型，尤其是基本数据类型，在必要的情况下，一个类型的值是可以被转换为另外一个可被转换的类型。 不同于其他语言，Go 语言不存在隐式类型转换，所有的类型转换都必须是显示的转换： 类型B的值 = 类型B(类型A的值) 类型转换只能在定义正确的情况下才能转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。 换言之，类型转换只能从低精度向高精度转换，否则将会存在精度丢失。 示例如下： package main import ( \"fmt\" ) func main() { // 类型转换 var i16 int16 = 10000 i32 := int32(i16) fmt.Print(i32) } 3.2 类型别名 类型别名是 Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 C/C++ 语言中，代码重构升级可以使用宏快速定义一段新的代码，Go 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。 在 Go 1.9 版本之前定义内建类型的代码是这样写的： type byte uint8 type rune int32 而在 Go 1.9 版本之后变为： type byte = uint8 type rune = int32 类型别名定义 定义类型别名的写法为： type TypeAlias = Type TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。 注意：类型别名与类型定义表面上只有一个等号的差异，那么它们之间实际的区别有哪些呢？通过下面的示例代码来理解。 示例如下： package main import \"fmt\" // 定义int类型的变量为NewInt type NewInt int // 定义int类型的别名IntAlias type IntAlias = int func main() { var a NewInt fmt.Printf(\"a type:%T\\n\", a) var a2 IntAlias fmt.Printf(\"a2 type:%T\\n\", a2) } 输出结果如下： a type:main.NewInt a2 type:int 4、小结 本文主要讲解 Go 语言中存在哪些数据类型，让你对所有数据类型有个整体的认识，学会对它们的基本使用（定义、初始化等）。从上面的学习中，你会发现 Go 语言相比其他语言是更加的灵活，弥补了其他语言数据类型的一些缺失、不便等。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"basics/conditions-and-loops.html":{"url":"basics/conditions-and-loops.html","title":"条件和循环","keywords":"","body":"条件和循环 在程序中必然少不了条件语句和循环语句，Go 语言在条件、循环语句方面与其他语言存在一定的差异，本文将针对 Go 语言中条件语句、循环语句的使用，这将会奠定后续复杂程序的基础。 1、条件语句 条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。 下图展示了程序语言中条件语句的结构： 图 3.4.1：条件语句结构 Go 语言提供了以下几种条件判断语句： 语句 描述 if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。 if...else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 switch 语句 switch 语句用于基于不同条件执行不同动作。 select 语句 select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 **注意：Go 没有三目运算符，所以不支持 `? :` 形式的条件判断。** 1.1 if 语句 语法 Go 编程语言中 if 语句的语法如下： if 布尔表达式 { // 在布尔表达式为 true 时执行 } if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。 布尔表达式可以不用 () 括起来，简洁了很多。 流程图如下： 图 3.4.2：if语句流程图 示例 使用 if 判断一个整数的大小，示例如下： package main import \"fmt\" func main() { var a int = 10 if a 输出结果如下： a 小于 20 1.2 if .. else 语句 语法 Go 编程语言中 if...else 语句的语法如下： if 布尔表达式 { // 在布尔表达式为 true 时执行 } else { // 在布尔表达式为 false 时执行 } if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。 流程图如下： 图 3.4.3：if else语句流程图 示例 使用 if else 判断一个整数的大小，示例如下： package main import \"fmt\" func main() { var a int = 30 if a 输出结果如下： a 大于 20 1.3 if 嵌套语句 语法 Go 编程语言中 if...else 语句的语法如下： if 布尔表达式 1 { // 在布尔表达式 1 为 true 时执行 if 布尔表达式 2 { // 在布尔表达式 2 为 true 时执行 } } 此外，也可以在if中嵌套 if..else 语句等条件语句。 示例 package main import \"fmt\" func main() { var a int = 30 var b int = 100 if a == 30 { if b == 100 { fmt.Printf(\"a = %d, b = %d\\n\", a, b) } } } 输出结果如下： a = 30, b = 100 1.4 switch 语句 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下，直到匹配为止。 和其它语言不同的是： switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。 switch 后面变量的类型可以是任何类型，不再局限于常量或整数。 语法 Go 编程语言中 switch 语句的语法如下： switch var1 { case val1: ... case val2: ... default: ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 流程图如下： 图 3.4.4：switch语句流程图 示例 package main import \"fmt\" func main() { var grade string = \"B\" var marks int = 90 switch marks { case 90: grade = \"A\" case 80: grade = \"B\" case 50, 60, 70: grade = \"C\" default: grade = \"D\" } switch { case grade == \"A\": fmt.Printf(\"优秀!\\n\") case grade == \"B\", grade == \"C\": fmt.Printf(\"良好\\n\") case grade == \"D\": fmt.Printf(\"及格\\n\") case grade == \"F\": fmt.Printf(\"不及格\\n\") default: fmt.Printf(\"差\\n\") } fmt.Printf(\"你的等级是 %s\\n\", grade) } 输出结果如下： 优秀! 你的等级是 A 1.5 select 语句 2、循环语句 在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。 以下为大多编程语言循环程序的流程图： 图 3.4.5：循环语句流程 与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构。 Go 语言提供了以下几种类型循环语句： 循环类型 描述 for 循环 重复执行相同逻辑的语句块。for 循环中也可以嵌套一个或多个 for 循环。在实际开发中，嵌套层数不要太深，一般 2 层即可。 for range 循环 能够帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。 在循环过程中，因实际需求需要在适当的条件下推出循环，此时循环控制语句则可以控制循环体内语句的执行过程。 Go 语言支持以下几种循环控制语句： 控制语句 描述 break 语句 经常用于中断当前 for 循环或跳出 switch 语句 continue 语句 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 语句 将控制转移到被标记的语句。 2.1 for 循环 语法 Go 语言 for 循环更加的灵活，有三种形式： for init; condition; post { // 循环体 } 类似于 do while： for condition { // 循环体 } 无限循环： for { // 循环体 } init： 一般为赋值表达式，给控制变量赋初值。 condition： 关系表达式或逻辑表达式，循环控制条件。 post： 一般为赋值表达式，给控制变量增量或减量。 示例 求 1~100 之间的求和，示例如下： package main import \"fmt\" func main() { sum := 0 for i := 1; i 2.2 for range 循环 除了使用经典的三段式循环之外，Go 语言还引入了一个新的关键字 range，用于帮助我们快速遍历数组等集合类型，非常简洁好用，成为了数组遍历的标配。 语法 for k,v := range arr { // 循环体 } k：数组 arr 的索引。 v：数组 arr 对应索引 k 的值。 示例 循环输出一个数组中的所有数据，示例如下： package main import \"fmt\" func main() { arr := []string{\"A\", \"B\", \"C\", \"D\"} for k, v := range arr { fmt.Printf(\"arr[%d]=%s\\n\", k, v) } } 输出结果如下： arr[0]=A arr[1]=B arr[2]=C arr[3]=D 2.3 break 语句 Go 语言中 break 语句用于以下三方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break 在 switch 中在执行一条 case 后跳出语句的作用。 在多重循环中，可以用标号 label 标出想 break 的循环。 语法 break 示例 示例如下： package main import \"fmt\" func main() { var a int = 10 for a 15 { break } } } 输出结果如下： a=10 a=11 a=12 a=13 a=14 a=15 使用多重循环，演示使用标记和不使用标记的区别，示例2如下： package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- break ----\") for i := 1; i 输出结果如下： ---- break ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 ---- break label ---- i: 1 i2: 11 2.4 continue 语句 Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 语法 continue 示例 示例如下： package main import \"fmt\" func main() { var a int = 10 for a 15 { continue } fmt.Printf(\"****\\n\") } } 输出结果如下： a=10 **** a=11 **** a=12 **** a=13 **** a=14 **** a=15 a=16 a=17 a=18 a=19 2.5 goto 语句 Go 语言的 goto 语句可以无条件地跳转到任意指定位置。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。（这与 Java 语言中一样，不推荐使用。） 语法 goto label .. . label: statement 示例 示例如下： package main import \"fmt\" func main() { var b int = 10 for b 15 { goto print } } print: fmt.Printf(\"****\\n\") } 输出结果如下： b=10 b=11 b=12 b=13 b=14 b=15 **** Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-21 22:48:08 "},"packages/packages.html":{"url":"packages/packages.html","title":"包的介绍和使用","keywords":"","body":"包的介绍和使用 Go 语言像 Java 语言一样都拥有包的概念，通过使用包来组织源代码。包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。 任何 Go 源代码文件都必属于某个包，同时源码文件的第一行有效代码必须是 package pacakgeName 语句，通过该语句声明自己所在的包。 1、包的概述 Go 语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然 Go 语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样代码结构会更加清晰。 1.1 包的定义 包的声明如下： package 注意：包声明必须在 go 源文件的第一行定义。 例如，在 GOPATH/src/a/b/ 下定义包 c，则在 GOPATH/src/a/b/ 目录下的所有 go 源文件第一行需要声明 package c，而不是声明为 package a.b.c 或 package a/b/c，但在导入包时，需要带上路径 import a/b/c。（注意：这与 Java 语言中包的用法差异很大） 1.2 包的命名规范 清晰的代码结构，少不了规范命名，包的命名更为重要。规范命名的目的是为了让你的代码更清晰，别人读起来更快上手。包命名规范推荐如下： 包名一般小写，使用一个简短且有意义的单词或缩写。 包名与所在包的目录同名，看目录知包名。 包名一般采用域名作为包目录结构，以此来确保唯一性。如：GOPATH/src/github.com/xcbeyond/projectName/...。 程序入口包名必须是 main 包。 同一目录下的所有 go 源文件都属于同一个包。 2、包的使用 有了包的存在，必然少不了对其导入，可借助 import 关键字导入想使用的包。具体语法如下： import \"包路径\" 注意： import 导入语句需放在源码文件开头的包声明语句的下面。 导入的包名需要使用双引号 \"\" 括起来。 包名是从 GOPATH/src/ 后开始计算的，使用 / 进行路径分隔。 通常导入包有单行导入和多行导入两种方式。 单行导入： import \"包1路径\" import \"包2路径\" 多行导入： import ( \"包1路径\" \"包2路径\" ) 2.1 导入路径 关于包的导入路径有两种方式，分别是全路径导入和相对路径导入。 全路径导入： 包的绝对路径就是 GOROOT/src/ 或 GOPATH/src/ 后面包的存放路径，如下所示： import \"lab/test\" import \"database/sql/driver\" import \"database/sql\" 其中： test 包是自定义的包，其源码位于 GOPATH/src/lab/test 目录下。 driver 包的源码位于 GOROOT/src/database/sql/driver 目录下。 sql 包的源码位于 GOROOT/src/database/sql 目录下。 相对路径导入： 相对路径只能用于导入 GOPATH 下的包，标准包的导入只能使用全路径导入。 例如，包 a 的所在路径是 GOPATH/src/lab/a，包 b 的所在路径为 GOPATH/src/lab/b，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下： // 相对路径导入 import \"../a\" 2.2 包的引用 包的引用有四种格式，下面以 fmt 包为例分别进行说明。 2.2.1 标准引用格式 import \"fmt\" 用 fmt. 作为前缀来使用 fmt 包中的方法，这是最为常用的一种方式。 示例如下： package main import \"fmt\" func main() { fmt.Println(\"Hello World!\") } 2.2.2 自定义别名引用格式 在导入包的时候，我们可以为导入的包设置别名，简化使用： import F \"fmt\" 其中 F 就是 fmt 包的别名，可以用 F.来代替标准引用格式的 fmt. 来作为前缀使用 fmt 包中的方法。 示例如下： package main import F \"fmt\" func main() { F.Println(\"Hello World!\") } 2.2.3 省略引用格式 import . \"fmt\" 相当于把 fmt 包直接合并到当前源文件中，在使用 fmt 包内的方法是可以不用加前缀 fmt.而直接引用。 示例如下： package main import . \"fmt\" func main() { Println(\"Hello World!\") } 2.2.4 匿名引用格式 在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式： import _ \"fmt\" 使用标准格式引用包，但代码中却没有使用包，编译器是会报错。如果包中有 init 初始化函数，则通过import _ \"包的路径\" 这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。 示例如下： package main import ( _ \"database/sql\" \"fmt\" ) func main() { Println(\"Hello World!\") } 2.3 包的初始化 通过前面的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 main 包的 main 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示： 图 4.1.1：包的初始化 Go语言包的初始化有如下特点： 包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。 Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。 单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 init 函数。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-30 23:17:38 "},"packages/gopath.html":{"url":"packages/gopath.html","title":"包管理工具之GOPATH","keywords":"","body":"包管理工具之GOPATH 当我们真正用 Go 去做项目，或者阅读 Go 项目（如，Go 实现的开源项目）时，不可避免的会遇到包依赖问题，一些包管理方式总是很难区分、选择。Go的包管理与Java的Maven依赖管理不太一样，起初Go的包管理方式经常会被人吐槽，但随之Go版本的升级也出现了不同的包管理方式，以满足不同的需求。 今天，我们就 GOPATH 开始来了解 Go 最基本的包管理方式，让你彻底认清它。（虽然很简单，但作为系列文章还是有必然单独说一下的） 1、GOPATH GOPATH, 被称之为“工作目录”，是 Go 语言中使用的一个环境变量，它使用绝对路径提供Go项目的绝对路径，类似于 eclipse 中的工作空间 workspace。 工作目录是一个工程开发的相对参考目录，好比当你要在公司编写一套服务器代码，你的工位所包含的桌面、计算机及椅子就是你的工作区。工作区的概念与工作目录的概念也是类似的。如果不使用工作目录的概念，在多人开发时，每个人有一套自己的目录结构，读取配置文件的位置不统一，输出的二进制运行文件也不统一，这样会导致开发的标准不统一，影响开发效率。 GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。 1.1 GOPATH的基本使用 其实早在1.2 Go语言从入门到精通：开发环境搭建一文中已经涉及到了 GOPATH，GOPATH的配置在安装时已经设置过了。 查看 因GOPATH作为一个环境变量而存在，可直接输入命令 go env来查看： C:\\Users\\Administrator>go env …省略其它… set GOPATH=E:\\github …省略其它… 从命令行输出中，可以看到 GOPATH 设定的路径为：E:\\github。（该GOPATH是我手动修改过的） 在 Go 1.8 版本之前，GOPATH 环境变量默认为空。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录。 设置 选择一个目录，执行命令set GOPATH=： C:\\Users\\Administrator>set GOPATH=E:\\github Linux环境下，执行命令 export GOPATH=。 1.2 GOPATH工程结构 在GOPATH目录下会存在三个文件夹： 目录 描述 src 代码，可以创建多个不同的包，手动创建对应包目录。 bin 编译代码生成的二进制文件。 pkg 编译生成的中间缓存文件。 bin、pkg 是在编译时（如，执行go build、go install 、go get等命令）创建。 例如： bin/ hello # command executable outyet # command executable pkg/ …… src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source golang.org/x/image/ .git/ # Git repository metadata bmp/ reader.go # package source writer.go # package source 1.3 GOPATH和GOROOT的区别 不同于其他语言，Go 语言中没有项目的说法，只有包的概念。其中，GOROOT 和 GOPATH 很容易被大家混为一谈。 GOROOT： Go 语言的安装目录。（类似于 Java 的 JDK，存放的是一些内置包、编译工具等） GOPATH：我们的工作空间，即：保存 Go 的代码和第三方依赖包。 2、小结 GOPATH 是最早的依赖包管理方式，是将所有的本地代码和第三方包代码均放在 GOPATH/src 目录下，它的优点是统一管理，方便查询和引用。 但是在使用过程中会有一个非常严重的问题，那就是由于所有不同的项目都放在 GOPATH/src 目录下，当多个不同项目引用的是同一个第三方包，但是该第三包的不同版本时，便会导致严重的包依赖问题。 因此，这也是 Go 语言之初被诟病的一个点，那么该如何解决上述问题呢？ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-23 22:57:41 "},"packages/govendor.html":{"url":"packages/govendor.html","title":"包管理工具之Go Vendor","keywords":"","body":"包管理工具之Go Vendor Govendor 是 Go 的另一个依赖包管理工具，它的出现可以避免不同用户在 clone 同一个工程后从外部获取不同依赖库版本的问题，很好的弥补了 GOPATH 包管理的缺陷。govendor 会将工程需要的依赖包添加到工程的 vendor 目录下，并且该目录中 vendor.json 文件会保存添加的依赖包的路径等信息。 （出于知识体系的完整性以及对各类包管理工具的全面了解，本文重点只是介绍Govendor 的存在，并不推荐使用它，仅作了解即可。） 1、Govendor 概述 Go 工程的依赖包经常使用 go get 命令来获取，例如：go get github.com/spf13/cobra/cobra ，会将依赖包下载到 GOPATH 的路径下。 随着 Go 的不断升级，在 Go 1.5版本之后，Go 提供了 GO15VENDOREXPERIMENT 环境变量(Go 1.6版本默认开启该环境变量)和 Govendor 包管理工具，用于将 go build 时的应用路径搜索调整成为当前工程/vendor 目录的方式，有效的解决了不同工程使用自己独立的依赖包目录。 1.1 Govendor介绍 Govendor 是 Go 1.5版本之后引入包管理工具。 其基本思路是，将引用的外部包的源代码放在当前工程的 vendor目录下面（类似于 Nodejs 的 node_modules 目录），Go 1.5 以后编译 Go 代码会优先从vendor目录先寻找依赖包，vendor目录如果没有找到，然后在 GOPATH 中查找，都没找到最后在 GOROOT 中查找。 特点： 可以采用 govendor add/update 从$GOPATH 复制现有的依赖。 如果要忽视 vendor/*/，可采用 govendor 同步恢复依赖。 可直接通过 govendor fetch 控制器添加新的依赖或者更新现有依赖。 可采用 govendor migrate 实现系统间迁移。 支持 Linux, OS X, Windows，甚至现有所有操作系统。 支持Git，Hg，SVN，BZR（必须指定一个路径）。 1.2 解决的问题 不同版本依赖问题：解决不同用户在 clone 同一个工程后从外部获取不同依赖库版本的问题。 迁移问题：将 Go 源码拷贝到当前工程的 vendor目录下，这样打包当前的工程代码到任意机器的 $GOPATH/src下都可以通过编译，避免项目代码外部依赖过多。迁移后， 无需再次 go get 拉取外部依赖包，况且再次 go get 重新拉取的外部依赖包的版本可能和工程开发时使用的不一致，将会导致编译错误问题。 1.3 常用命令 govendor 提供了很多命令供大家使用，下面列举了一些常用命令，更多命令可通过 govendor --help 查看。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似 go get 目录，拉取依赖包到 vendor 目录 2、快速入门 2.1 安装 使用 go get命令快速安装： go get -u -v github.com/kardianos/govendor 建议将 $GOPATH/bin 加入到 PATH 中，方便直接使用 govendor 命令。 2.2 初始化 进入项目根目录下执行 govendor init 命令，会在项目根目录下自动新建一个 vendor 目录，并在其中生成vendor.json(存储包的版本信息) govendor init 2.3 拉取包 使用 govendor fetch 或 govendor get 命令远程拉取外部依赖包。 例如： govendor fetch github.com/spf13/cobra/cobra 3、小结 本文主要是讲解了一下 Govendor 的存在以及如何使用，但随着Go 的不断壮大，随之被 Go modules 而取代了，所以不推荐使用 Govendor。下一篇文章将会对 Go modules 展开说明，它将作为目前包管理工具的首选，也是必选。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-23 22:57:41 "},"packages/gomodule.html":{"url":"packages/gomodule.html","title":"包管理工具之Go Module","keywords":"","body":"包管理工具之Go Module Go modules 是 Go 语言目前最佳的依赖解决方案，发布于 Go 1.11版本，Go1.14版本 上已经明确建议生产上使用。而 Go modules 之前，Go 项目使用 GOPATH 、Govendor包管理方式，但却都存在一定的问题，本文就重点讨论关于另外一个包管理工具 Go module 的由来及使用。 1、Go module 概述 1.1 Go module介绍 使用 GOPATH 包管理方式，最严重的问题就是当使用go get 命令时，没有版本选择机制，拉取下来的依赖代码都会默认当前最新版本，而且如果当项目 A 和项目 B 分别依赖项目 C 的两个不兼容版本时， GOPATH 路径下只有一个版本，则 C 将无法同时满足 A 和 B 的依赖需求。这可以说是一个很大的缺陷了，因而 Go 1.13版本 起，官方就不再推荐使用 GOPATH 方式了。 随着 Go 语言使用人数的增长，依赖包的丰富，依赖版本问题尤其严重。 于是 Go 官方在 Go 1.5版本的时候提出了实验性质的 vendor 机制：每个项目都可以有一个vendor/ 目录来存放项目所需版本依赖的拷贝。 社区中基于官方给的机制，开发出了各种版本管理工具。比较流行的比如 govendor，以及之前曾被官方认定的 godep 工具等。 这些工具的思路基本都是为每个项目单独维护一份对应版本依赖的拷贝。 管理工具虽然丰富了起来，但是不同版本工具之间不兼容，无法协作，各种工具还都有学习成本。这时候在 Go 官方扶持下成立的 dep 项目被大家认为是未来一统江湖的版本管理工具，被称作 official experiment。 dep 采用了和 Rust 的管理工具 Cargo 类似的管理模式，原理在此不深究。 没过多久，Go 社区的核心人物 rsc 提出了 vgo 方案。一时间竟然出现了两个所谓的 Go 官方的版本管理方案。最终官方采用了 vgo 方案，随着 vgo 的逐渐成熟，Go 1.11版本发布了该功能，并集成到了 Go 的官方工具中，也就是当前的 Go modules。 Go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go 1.13 版本开始，Go module 成为了Go 语言默认的依赖管理工具。 Modules 官方定义为： Modules 是相关 Go 包的集合，是源代码交换和版本控制的单元。Go 语言命令直接支持使用 Modules，包括记录和解析对其他模块的依赖性，Modules 替换旧的基于 GOPATH 的方法，来指定使用哪些源文件。 1.2 Go module 常用命令 命令 作用 go mod download 下载依赖包到本地（默认为 GOPATH/pkg/mod 目录） go mod edit 编辑 go.mod 文件 go mod graph 打印模块依赖图 go mod init 初始化当前文件夹，创建 go.mod 文件 go mod tidy 增加缺少的包，删除无用的包 go mod vendor 将依赖复制到 vendor 目录下 go mod verify 校验依赖 go mod why 解释为什么需要依赖 2、快速入门 2.1 设置环境变量 要使用 Go module 必须确保 Go 版本在1.11之上。 设置 GO111MODULE 在Go 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go 1.13及以后的版本，则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。 GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。 GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod下载依赖。 GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。 Window： set GO111MODULE=on // 或者 set GO111MODULE=auto MacOS 或 Linux： export GO111MODULE=on // 或者 export GO111MODULE=auto 2.2 项目初始化 在 GOPATH 目录之外新建一个目录，并使用 go mod init 初始化生成 go.mod 文件。 E:\\github\\golangLearning>go mod init golangLearning go: creating new go.mod: module golangLearning go: to add module requirements and sums: go mod tidy 初始化生成的 go.mod 文件如下所示： module golangLearning go 1.16 2.3 添加依赖 新建一个 main.go 文件，代码如下： package main import ( \"net/http\" \"github.com/labstack/echo\" ) func main() { e := echo.New() e.GET(\"/\", func(c echo.Context) error { return c.String(http.StatusOK, \"Hello, World!\") }) e.Logger.Fatal(e.Start(\":1323\")) } 执行 go run main.go 命令运行代码，会发现 go mod 会自动查找依赖自动下载： E:\\github\\golangLearning>go run main.go go: finding module for package github.com/labstack/echo go: downloading github.com/labstack/echo v1.4.4 go: downloading github.com/labstack/echo v3.3.10+incompatible go: found github.com/labstack/echo in github.com/labstack/echo v3.3.10+incompatible go: finding module for package github.com/stretchr/testify/assert go: finding module for package github.com/labstack/gommon/log go: finding module for package github.com/labstack/gommon/color go: finding module for package golang.org/x/crypto/acme/autocert go: downloading github.com/labstack/gommon v0.3.0 go: downloading golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2 go: found github.com/labstack/gommon/color in github.com/labstack/gommon v0.3.0 go: found github.com/labstack/gommon/log in github.com/labstack/gommon v0.3.0 go: found golang.org/x/crypto/acme/autocert in golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2 go: found github.com/stretchr/testify/assert in github.com/stretchr/testify v1.7.0 go: downloading github.com/mattn/go-colorable v0.1.2 go: downloading github.com/valyala/fasttemplate v1.0.1 go: downloading github.com/mattn/go-isatty v0.0.9 go: downloading github.com/davecgh/go-spew v1.1.0 go: downloading gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c go: downloading golang.org/x/text v0.3.3 go: downloading github.com/valyala/bytebufferpool v1.0.0 go: downloading golang.org/x/sys v0.0.0-20201119102817-f84b799fce68 ____ __ / __/___/ / ___ / _// __/ _ \\/ _ \\ /___/\\__/_//_/\\___/ v3.3.10-dev High performance, minimalist Go web framework https://echo.labstack.com ____________________________________O/_______ O\\ ⇨ http server started on [::]:1323 exit status 3221225786 再查看 go.mod 文件： module golangLearning go 1.16 require ( github.com/labstack/echo v3.3.10+incompatible github.com/labstack/gommon v0.3.0 // indirect github.com/stretchr/testify v1.7.0 // indirect golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2 // indirect ) 此外，会自动生成一个 go.sum 文件来记录 dependency tree： github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8= github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38= github.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg= github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s= github.com/labstack/gommon v0.3.0 h1:JEeO0bvc78PKdyHxloTKiF8BD5iGrH8T6MSeGvSgob0= github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k= github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU= github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE= github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s= github.com/mattn/go-isatty v0.0.9 h1:d5US/mDsogSGW37IV293h//ZFaeajb69h+EHFsv2xGg= github.com/mattn/go-isatty v0.0.9/go.mod h1:YNRxwqDuOph6SZLI9vUUz6OYw3QyUt7WiY2yME+cCiQ= github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM= github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4= github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME= github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4= github.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY= github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg= github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw= github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc= github.com/valyala/fasttemplate v1.0.1 h1:tY9CJiPnMXf1ERmG2EyK7gNUd+c6RKGD0IfU8WdUSz8= github.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8= golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2 h1:It14KIkyBFYkHkwZ7k45minvA9aorojkyjGk9KJ5B/w= golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4= golang.org/x/net v0.0.0-20210226172049-e18ecbb05110 h1:qWPm9rbaAMKs8Bq/9LRpbMqxWRVUAQwMI9fVrssnTfw= golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg= golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY= golang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs= golang.org/x/sys v0.0.0-20201119102817-f84b799fce68 h1:nxC68pudNYkKU6jWhgrqdreuFiOQWj1Fs7T3VrH4Pjw= golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs= golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo= golang.org/x/text v0.3.3 h1:cokOdA+Jmi5PJGXLlLllQSgYigAEfHXJAERHVMaCc2k= golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ= golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ= gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0= gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI= gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo= gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM= 3、小结 至此，是不是感觉Go module 很好用，再也不用依赖 GOPATH了，灵活方便。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-23 22:57:41 "},"packages/fmt-package.html":{"url":"packages/fmt-package.html","title":"标准输入输出fmt包","keywords":"","body":"标准输入输出fmt包 在程序的任何阶段，我们可能都会需要输入/输出一些数据，以及通过输入/输出记录各种数据以进行程序调试，这种基本的输入/输出将有助于我们编写更好的代码。然而 fmt 包就很好的提供了标准输入输出，便于进行打印等，本文将针对 fmt 包进行讨论。 1、fmt 包 fmt 包实现了格式化的输入输出，这与 C 语言中的 printf 和 scanf 类似，它属于Go 的内置包，在安装 Go 的时候会自动安装到系统中，位于 $GOROOT\\src\\pkg\\fmt目录中，其中包括以下源代码： doc.go errors.go format.go print.go scan.go 1.1 常用函数 该包主要实现了字符串格式支持的读写功能，常用的函数有： Fprint，Fprintf和 Fprintln Sprint，Sprintf 和 Sprintln Print，Printf 和 Println Fscan，Fscanf 和 Fscanln Sscan，Sscanf 和Sscanln 上述函数长的都很相似，很容易混淆、用错，在这里介绍一些方法方便区分它们。 F 开头的：都是将字符串作为输入或输出参数，并且该参数都是实现 io.Writer 或 io.Reader 接口。 S 开头的：都是以格式化占位符创建的字符串返回。 f 结尾的：都是支持格式化占位符。 ln 结尾的：都是在输入或输出完添加了换行符\\n。 1.2 格式化占位符 fmt 包在进行输入、输出时，都可采用格式化占位符完成格式化的处理，支持的格式化占位符如下： （对应代码：https://github.com/xcbeyond/golangLearning/blob/main/ch3/fmt/format/formatTest.go） 普通占位符 定义一个结构体Person，并赋值： type Person struct { Name string } var p = new(Person) p.Name = \"xcbeyond\" 占位符 说明 示例 输出 %v 相应值的默认格式 fmt.Printf(\"%v\", p.Name) xcbeyond %+v 打印结构体时，会添加字段名 fmt.Printf(\"%+v\\n\", p) &{Name:xcbeyond} %#v 相应值的Go语法表示 fmt.Printf(\"%#v\\n\", p) &main.Person{Name:\"xcbeyond\"} %T 相应值的类型 fmt.Printf(\"%T\\n\", p.Name) string %% 字面上的百分号 fmt.Printf(\"%%\\n\") % 布尔占位符 占位符 说明 示例 输出 %t true 或 false fmt.Printf(\"%t\",1 == 1) true 整数占位符 占位符 说明 示例 输出 %b 二进制表示 fmt.Printf(\"%b\", 5) 101 %c 相应 Unicode 码所表示的字符 fmt.Printf(\"%c\", 0x4E2D) 中 %d 十进制表示 fmt.Printf(\"%d\", 0x12) 18 %o 八进制表示 fmt.Printf(\"%d\", 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 fmt.Printf(\"%q\", 0x4E2D) 中 %x 十六进制表示，字母形式为小写 a-f fmt.Printf(\"%x\", 13) d %X 十六进制表示，字母形式为大写 A-F fmt.Printf(\"%x\", 13) D %U Unicode 格式：U+1234等同于 U+%04X fmt.Printf(\"%U\", 0x4E2D) U+4E2D 复数(实部、虚部)占位符 占位符 说明 示例 输出 %e 科学计数法，可保留几位小数，如：%.3e表示保留三位小数 fmt.Printf(\"%.3e\\n\", math.Pi) 3.142e+00 %E 科学计数法 fmt.Printf(\"%E\\n\", math.Pi) 3.141593E+00 %f 科学计数法，可保留几位小数而无指数 fmt.Printf(\"%.3f\\n\", math.Pi) 3.142 %g 根据状况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 fmt.Printf(\"%.3g\\n\", math.Pi) 3.14 %G 根据状况选择 %E 或 %f以产生更紧凑的（无末尾的0）输出 fmt.Printf(\"%.3G\\n\", 10.20+5i) (10.2+5i) 字符串占位符 □：表示一个空格 占位符 说明 示例 输出 %s 输出字符串表示 fmt.Printf(\"%s\\n\", \"xcbeyond\") xcbeyond %10s 输出字符串最小宽度为10(右对齐) fmt.Printf(\"%10s\\n\", \"xcbeyond\") □□xcbeyond %-10s 输出字符串最小宽度为10(左对齐) fmt.Printf(\"%-10s\\n\", \"xcbeyond\") xcbeyond□□ %.5s 输出字符串最大宽度为5 fmt.Printf(\"%.5s\\n\", \"xcbeyond\") xcbey %5.10s 输出字符串最小宽度为5，最大宽度为10 fmt.Printf(\"%5.10s\\n\", \"xcbeyond\") xcbeyond %-5.10s 输出字符串最小宽度为5，最大宽度为10(左对齐) fmt.Printf(\"%-5.10s\\n\", \"xcbeyond\") xcbeyond %5.3s 输出字符串宽度为5，若是原字符串宽度大于3，则截断 fmt.Printf(\"%5.3s\\n\", \"xcbeyond\") □□xcb %010s 若是宽度小于10，就会在字符串前面补零 fmt.Printf(\"%010s\\n\", \"xcbeyond\") 00xcbeyond %q 双引号围绕的字符串，由Go语法安全地转义 fmt.Printf(\"%q\\n\", \"xcbeyond\") \"xcbeyond\" %x 十六进制，小写字母，每字节两个字符 fmt.Printf(\"%x\\n\", \"xcbeyond\") 78636265796f6e64 %X 十六进制，大写字母，每字节两个字符 fmt.Printf(\"%X\\n\", \"xcbeyond\") 78636265796F6E64 指针占位符 占位符 说明 示例 输出 %p 十六进制表示，前缀 0x fmt.Printf(\"%p\\n\", &p) 0xc00011a020 %#p 不带前缀 0x fmt.Printf(\"%#p\\n\", &p) c00011a020 2、输出 Go 语言的标准输出是指将输出内容直接输出到控制台上，根据不同的输出需求选择不同的函数，这些函数基本都位于 $GOROOT\\src\\fmt\\print.go 中，各个函数具体使用如下。 2.1 fmt.Print fmt.Print 使用默认格式输出，其函数定义如下： // Print formats using the default formats for its operands and writes to standard output. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered. func Print(a ...interface{}) (n int, err error) { return Fprint(os.Stdout, a...) } 示例如下： name := \"xcbeyond\" fmt.Print(name) // xcbeyond 2.2 fmt.Printf fmt.Printf 根据格式化占位符进行格式化，并标准输出，其函数定义如下： // Printf formats according to a format specifier and writes to standard output. // It returns the number of bytes written and any write error encountered. func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) } 示例如下： name := \"xcbeyond\" fmt.Printf(\"%.5s\", name) // xcbey 2.3 fmt.Println fmt.Println 使用默认格式输出，并换行，其函数定义如下： // Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } 示例如下： name := \"xcbeyond\" fmt.Println(name) // xcbeyond 换行 2.4 fmt.Sprint fmt.Sprint使用默认格式返回结果字符串，其函数定义如下： // Sprint formats using the default formats for its operands and returns the resulting string. // Spaces are added between operands when neither is a string. func Sprint(a ...interface{}) string { p := newPrinter() p.doPrint(a) s := string(p.buf) p.free() return s } 示例如下： name := \"xcbeyond\" retStr := fmt.Sprint(name) fmt.Print(retStr) // xcbeyond 2.5 fmt.Sprintf fmt.Sprintf 根据格式化占位符进行格式化，返回结果字符串，其函数定义如下： // Sprintf formats according to a format specifier and returns the resulting string. func Sprintf(format string, a ...interface{}) string { p := newPrinter() p.doPrintf(format, a) s := string(p.buf) p.free() return s } 示例如下： name := \"xcbeyond\" retStr2 := fmt.Sprintf(\"%.5s\", name) fmt.Print(retStr2) // xcbey 2.6 fmt.Sprintln fmt.Sprintln 使用默认格式，返回结果字符串，其函数定义如下： // Sprintln formats using the default formats for its operands and returns the resulting string. // Spaces are always added between operands and a newline is appended. func Sprintln(a ...interface{}) string { p := newPrinter() p.doPrintln(a) s := string(p.buf) p.free() return s } 示例如下： name := \"xcbeyond\" retStr3 := fmt.Sprintln(name) fmt.Print(retStr3) // xcbeyond 换行 2.7 fmt.Fprint // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered. func Fprint(w io.Writer, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrint(a) n, err = w.Write(p.buf) p.free() return } 2.8 fmt.Fprintf // Fprintf formats according to a format specifier and writes to w. // It returns the number of bytes written and any write error encountered. func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrintf(format, a) n, err = w.Write(p.buf) p.free() return } 2.9 fmt.Fprintln // Fprintln formats using the default formats for its operands and writes to w. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Fprintln(w io.Writer, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrintln(a) n, err = w.Write(p.buf) p.free() return } 3、输入 3.1 fmt.Fscan 3.2 fmt.Fscanf 3.3 fmt.Fscanln 3.4 fmt.Scan 3.5 fmt.Scanf 3.6 fmt.Scanln 3.7 fmt.Sscan 3.8 fmt.Sscanf 3.9 fmt.Sscanln 参考资料： https://golang.org/pkg/fmt/ https://golangdocs.com/fmt-package-golang https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-23 22:57:41 "},"functions/functions.html":{"url":"functions/functions.html","title":"函数的介绍和使用","keywords":"","body":"函数的介绍和使用 常量和变量都是数据的一种载体，数据通过不同的运算符参与运算时，对计算的流程进行一定程度的控制便是流程控制，并且低于较多的数据通过内置容器进行存储，那么之后要干嘛呢？就是通过以上的所有概念进行整合，将其抽象到一个模块中去完成某一功能，这便是本篇的主题——函数。 函数，并不是一个新概念，在不同语言中都能听到函数这个名词，那么在 Go 语言中函数又该如何使用呢？它到底与其他语言又有哪些差异呢？ 1、函数定义 Go 语言中，函数定义是以关键字 func 开始，其标准格式如下： func 函数名(参数列表) (返回参数列表) { 函数体 } 定义解析： func：函数由关键字 func 开始，来表明这是一个函数。 函数名：函数名称，需符合变量命名规范，函数名和参数列表一起构成了函数签名。在同一个包内不能定义相同的函数名。（记住：Go 语言中，是不支持函数重载的！） 参数列表：参数就是一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 返回类型：函数返回一列值的数据类型。有时是不需要返回值的，此时返回类型可以没有。 函数体：函数定义的代码集合，用来实现具体的函数逻辑。 根据函数参数情况可分为三类，接下来展开具体说明。 固定参数 可变参数 固定参数和可变参数 1.1 固定参数的函数定义 函数定义格式如下： func 函数名(参数列表) (返回参数列表) { 函数体 } 例如，两数相乘： func multipleForTowNum(num1 int, num2 int) int { result := num1 * num2 return result } 1.2 可变参数的函数定义 Go 语言中还支持另外一种可变参数的函数，其函数定义格式如下： func 函数名(v...T) (返回参数列表) { 函数体 } 注：v...T 表明 v 为一个切片，T 为切片中数据的类型。 例如，实现多数相乘： func multipleForNums(nums ...int) int { var result int = 1 for _, num := range nums { result = result * num } return result } 其中，nums为切片，用来存放不定长度的int类型数组。 1.3 固定参数和可变参数的函数定义 上面介绍了固定参数、可变参数的定义，如果存在固定参数和可变参数共存的情况，该如何定义呢？ 其格式如下： func 函数名(固定参数列表, v...T) (返回参数列表) { 函数体 } 例如，在两数相加基础上，再进行多数的相乘： func multipleForTowNums(num1 int, num2 int, nums ...int) int { result := num1 + num2 for _, num := range nums { result = result * num } return result } 2、函数分类 函数从大的方面分类两类：自定义函数、内置函数。 2.1 自定义函数 比如，上一小节函数定义中的举例函数都属于自定义函数，根据实际需求以关键字 func 开头的函数。另一方面，自定义函数是相对Go 语言内置函数而言，指内置函数以外的函数。 2.2 内置函数 内置函数，是指在使用时无需导入包而直接使用的函数，如 len、append 等。在 Go 语言一共有15个内置函数，如下所示： 函数名 说明 make 为切片、channel类型分配内存并初始化对象。 len 计算数组、切片、映射 map、通道 channel 的长度。 cap 计算数组、切片、通道 channel 的容量。 delete 删除映射 map 中对应的键值对。 append 将数据添加到原切片的末尾。 copy 将原切片的数据复制到新切片中，当新切片的空间不足时直接舍弃多余的数据。 new 为切片、映射 map、通道 channel 类型以外的类型分配内存并初始化对象，返回的类型为指针。 complex 生成一个复数。 real 返回复数的实部。 imag 返回复数的虚部。 print 将信息打印到标准输出。 println 将信息打印到标准输出并换行。 close 用于关闭通道 channel。 panic 用于触发宕机。 recover 用于捕获 panic 抛出的异常信息。 3、函数返回值 在函数定义中我们知道函数在使用调用时，通常会给调用者返回一个结果，这个结果被称为函数的返回值。 一个函数可以没有返回值，也可以有一个或多个返回值。 3.1 多返回值 例如，将两个数进行交换，并返回交换后的两数： func swap(x, y string) (string, string) { return y, x } 3.2 空白标识符 _ 是 Go 中的空白标识符。它可以代替任何类型的任何值，用处十分广泛。例如，当我们在调用一个多返回值的函数时，但只会用到其中一部分返回值而又不想凭空多声明多余变量，此时，空白标识符就发挥它的优势了。 例如，上面的两个数交换函数 swap: package main import \"fmt\" func main() { x, _ := swap(1, 5) fmt.Println(x) // 输出：5 } func swap(x, y int) (int, int) { return y, x } 4、函数使用 接下来，以一个简单示例来说明如何正确的使用函数。 如下所示是一个计算两数最大值的函数 max。 package main import \"fmt\" func main() { fmt.Print(max(10, 7)) } // 获取两数的最大值 func max(num1, num2 int) int { if num1 > num2 { return num1 } else { return num2 } } Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-30 23:17:38 "},"functions/defer.html":{"url":"functions/defer.html","title":"延迟函数defer","keywords":"","body":"延迟函数defer Go 语言中存在一个特殊的语句：defer 语句，它会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。 关键字 defer 的用法类似于面向对象编程语言 Java 中的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。 1、多个延迟执行语句 当有多个 defer 语句时，它们会以逆序执行（即后进先出）。 例如，下面的代码是将一系列的数值打印语句按顺序延迟处理： package main import \"fmt\" func main() { fmt.Println(\"defer begin\") defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\"defer end\") } 输出结果如下： defer begin defer end 3 2 1 结果分析如下： 代码的延迟顺序与最终的执行顺序是反向的。 延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。 2、使用延迟执行语句在函数退出时释放资源 处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。 defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。 2.1 使用延迟并发解锁 在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码： var ( // 一个演示用的映射 valueByKey = make(map[string]int) // 保证使用映射时的并发安全的互斥锁 valueByKeyGuard sync.Mutex ) // 根据键读取值 func readValue(key string) int { // 对共享资源加锁 valueByKeyGuard.Lock() // 取值 v := valueByKey[key] // 对共享资源解锁 valueByKeyGuard.Unlock() // 返回值 return v } 使用 defer 语句对上面的语句进行简化： func readValue(key string) int { valueByKeyGuard.Lock() // defer后面的语句不会马上调用, 而是延迟到函数结束时调用 defer valueByKeyGuard.Unlock() return valueByKey[key] } 2.2 使用延迟释放文件句柄 文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源。 在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码： // 根据文件名查询其大小 func fileSize(filename string) int64 { // 根据文件名打开文件, 返回文件句柄和错误 f, err := os.Open(filename) // 如果打开时发生错误, 返回文件大小为0 if err != nil { return 0 } // 取文件状态信息 info, err := f.Stat() // 如果获取信息时发生错误, 关闭文件并返回文件大小为0 if err != nil { f.Close() return 0 } // 取文件大小 size := info.Size() // 关闭文件 f.Close() // 返回文件大小 return size } 在上面的例子中，f.Close() 是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下： func fileSize(filename string) int64 { f, err := os.Open(filename) // 延迟调用Close, 此时Close不会被调用 defer f.Close() if err != nil { return 0 } info, err := f.Stat() if err != nil { // defer机制触发, 调用Close关闭文件 return 0 } size := info.Size() // defer机制触发, 调用Close关闭文件 return size } Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-07-30 23:17:38 "},"framework/cobra/cobra.html":{"url":"framework/cobra/cobra.html","title":"Cobra介绍","keywords":"","body":"Cobra介绍 最近一直在看 Istio（一个 Service Mesh 框架）相关的东西，当看到其源码时发现了一个新东西 Cobra，一查却发现这是个好东西，用的地方可不少，比如：Docker、Kubernetes 等都有它的身影存在。为了更好的了解这些开源框架（如，Istio、Kubernetes 等），势必需要对 Cobra 做一个详细的了解，后续可能用到它的地方会很多。今天就 Cobra 做一个整体的介绍，让我们对它能有所认识，或许今后你的项目中也会用到它。 1、Cobra 概述 Cobra 是一个 Golang 包，它提供了简单的接口来创建命令行程序。同时，Cobra 也是一个应用程序，用来生成应用框架，从而开发以 Cobra 为基础的应用。 图 8.1.1.1：Cobra 1.1 主要功能 Cobra 的主要功能如下： 简易的子命令行模式，如 app server， app fetch 等等。 完全兼容 posix 命令行模式。 嵌套子命令 subcommand。 支持全局，局部，串联 flags。 使用 cobra 很容易生成应用程序和命令（cobra init appname 和 cobra add cmdname）。 提供智能化的提示（如，输出 app srver 命令，将提示 你是要输入 app server 吗？）。 自动生成 commands 和 flags 的帮助信息。 自动生成详细的 help 信息，如 app -help。 自动识别帮助 flag、 -h，--help。 自动生成应用程序在 bash 下命令自动完成功能。 自动生成应用程序的 man 手册。 命令行别名。 自定义 help 和 usage 信息。 可选的与 viper 的紧密集成。 对于命令行程序而言，上面这些功能简直就是量身打造。 1.2 应用举例 Cobra 被用于许多 Go 项目中，例如：Kubernetes、Hugo和Github CLI等，更多广泛使用的项目有： （来源于：https://github.com/spf13/cobra/blob/master/projects_using_cobra.md） Arduino CLI Bleve CockroachDB Cosmos SDK Delve Docker (distribution) Etcd Gardener Giant Swarm's gsctl Git Bump Github CLI GitHub Labeler Golangci-lint GopherJS Helm Hugo Istio Kool Kubernetes Linkerd Mattermost-server Metal Stack CLI Moby (former Docker) Nanobox/Nanopack OpenShift Ory Hydra Ory Kratos Pouch ProjectAtomic (enterprise) Prototool Random Rclone Skaffold Tendermint Twitch CLI Werf 看了这些，一个字“赞”，两个字“优秀”! 了解了 Cobra 后，再去看这些 Kubernetes、etcd、Registry 等开源项目的代码时，也就大概知道如何去看了，这也就是我学习 Cobra 的目的。 2、概念 Cobra 是基于命令（commands）、参数（arguments ）、选项（flags）而创建的。 在具体了解、使用Cobra前有一些概念需要提前知晓一下：命令（commands）、参数（arguments ）、选项（flags）这几个概念。 commands：命令代表行为,一般表示 action，即运行的二进制命令服务。同时可以拥有子命令（children commands） arguments：参数代表命令行参数。 flags：选项代表对命令行为的改变，即命令行选项。二进制命令的配置参数，可对应配置文件。参数可分为全局参数和子命令参数。 最好的命令行程序在实际使用时，就应该像在读一段优美的语句，能够更加直观的知道如何与用户进行交互。执行命令行程序应该遵循一般的格式： APPNAME VERB NOUN --ADJECTIVE或 APPNAME COMMAND ARG --FLAG。 比如下面的示例: # server是 commands，port 是 flag hugo server --port=1313 # clone 是 commands，URL 是 arguments，brae 是 flag git clone URL --bare 再比如： xcbeyond@xcbeyonddeMacBook-Pro ~ % docker info --help Usage: docker info [OPTIONS] Display system-wide information Options: -f, --format string Format the output using the given Go template ` 你没有看错，像 Docker 这种这么复杂的命令都是用 Cobra 是实现的，其必有过人之处，下一节就让我们一起来看看如何实现一套属于自己的命令行工具吧！ Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-08-01 13:18:27 "},"framework/cobra/cobra-in-practice.html":{"url":"framework/cobra/cobra-in-practice.html","title":"Cobra实战","keywords":"","body":"Cobra 实战 实战是最好的学习方式！ 本节将从一个实战带你快速入门 Cobra。 环境准备 前提条件&环境 操作系统：MacOS Go 环境：go 1.16 Go 开发 IDE：VSCode (上述环境可以个人环境而定，不做限制) Cobra 安装 使用 go get 命令获取最新版本的 Cobra 库。下面命令将会安装 Cobra 及其相关依赖包： go get -u github.com/spf13/cobra/cobra 下载安装完 Cobra 后，打开 GOPATH 目录，在 bin 目录下会下载好 cobra 程序（Window: cobra.exe, MacOS: cobra）。 工程初始化 假设现需要开发一个基于 Cobra 的 CLI 的命令行程序，命名为 cobra-demo。 由于 Cobra 提供了代码生成器的功能，我们可以直接使用 Cobra 提供的初始化命令 cobra init 进行快速初始化创建 Cobra 工程。 切换到 GOPATH 目录（如，/Users/xcbeyond/github），执行命令 cobra init --pkg-name ,如下： xcbeyond@xcbeyonddeMacBook-Pro github % .\\bin\\cobra init cobra-demo --pkg-name github.com/xcbeyond/cobra-demo Your Cobra application is ready at /Users/xcbeyond/github/cobra-demo 初始化成功后，cobra-demo 程序目录结构如下： . ├── cmd │ ├── root.go │ └── show.go ├── go.mod ├── go.sum └── main.go 运行 执行命令 go run 运行： xcbeyond@xcbeyonddeMacBook-Pro cobra-demo % go run main.go A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. 实战 这里以一个简单的 time 命令为例，实战讲解如何 Cobra 开发一个命令。 功能如下： show：查看当前时间。 parse：指定时间格式 --format，parse 为 show 的子命令。 实现 show 命令 添加 show 命令 通过命令 cobra add 添加 show 命令： xcbeyond@xcbeyonddeMacBook-Pro cobra-demo % ../bin/cobra add show show created at /Users/xcbeyond/github/cobra-demo 此时，项目目录下会创建一个 show.go 文件，在该文件中可完成命令的具体操作逻辑。 下面是 show.go 文件的初始代码： // showCmd represents the show command var showCmd = &cobra.Command{ Use: \"show\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"show called\") }, } func init() { rootCmd.AddCommand(showCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // showCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // showCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } &cobra.Command 作为命令的定义，其中有如下变量： Use：用于指定具体的命令，如：show。 Short：命令的简短描述。 Long：命令的详细描述。 Run：命令执行入口，用于实现命令的具体处理逻辑。 rootCmd.AddCommand(showCmd) 命令的添加，将命令添加到根命令。（Cobra 支持命令的子命令） 实现显示当前时间逻辑 在 &cobra.Command.Run 中添加获取当前时间逻辑 time.Now()： var showCmd = &cobra.Command{ Use: \"show\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { // show current time fmt.Println(time.Now()) }, } 修改 help 命令 help 命令有两个，一个是 short，一个是 lang，很明显 short 命令用来定义简短的说明，lang 命令用来定义详细说明，下面我们修改 show 命令的 help: var showCmd = &cobra.Command{ Use: \"show\", Short: \"Displays the current time\", Long: `You can use the time show command to view the current time. For example: $ ./cobra-demo show 2021-03-19 14:34:20.9320241 +0800 CST m=+0.378845301`, Run: func(cmd *cobra.Command, args []string) { // show current time fmt.Println(time.Now()) }, } 运行 执行 show 命令： xcbeyond@xcbeyonddeMacBook-Pro cobra-demo % go run main.go show 2021-07-31 14:49:27.3582836 +0800 CST m=+0.176660901 执行 show --help 命令： xcbeyond@xcbeyonddeMacBook-Pro cobra-demo % go run main.go show --help You can use the time show command to view the current time. For example: $ ./cobra-demo show 2021-07-31 14:34:20.9320241 +0800 CST m=+0.378845301 Usage: cobra-demo show [flags] Flags: -h, --help help for show Global Flags: --config string config file (default is $HOME/.cobra-demo.yaml) 总结 Cobra-demo 只是简单的阐述了由几部分组成，在实际项目中要比这复杂的很多，一般都是拥有多个子命令，但核心内容都是类似的。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-08-01 13:25:12 "}}